---
title: "dabestr-v1"
output: 
  html_document:
    toc: true
    toc_float: true
    df_print: paged
date: '2023-06-24'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(dplyr)
library(stringr)
library(lubridate)
library(cowplot)
library(rlang)
library(magrittr)
library(ggbeeswarm)
library(boot)
library(effsize)
library(grid)
library(scales)
library(ggsci)
library(colorspace)
library(roxygen2)
```

# load function
```{r}
load <- function(
    data,
    x = NULL,
    y = NULL,
    idx = NULL,
    paired = NULL,
    id_col = NULL,
    ci = 95,
    colour = NULL,
    proportional = FALSE,
    minimeta = FALSE,
    delta2 = FALSE
    ){
  
  # Storing plotting params as quosures
  enquo_x <- enquo(x)
  enquo_y <- enquo(y)
  enquo_id_col <- enquo(id_col)
  enquo_colour <- enquo(colour)
  
  is_colour <- isTRUE(as_label(enquo_colour) != "NULL")
  is_paired <- isFALSE(is.null(paired))
  
  # to add: if is_paired is TRUE --> id_col cannot be NULl
  # to add: paired must be either "baseline" or "sequential"
  
  name_x <- as_name(enquo_x)
  name_y <- as_name(enquo_y)
  
  unlist_idx <- unlist(idx)
  
  if (!is.null(idx)){
    raw_data <- data %>%
      filter(!!enquo_x %in% unlist_idx) %>%
      mutate(x_axis_raw = 0)
    
    raw_data[[name_x]] = factor(x = raw_data[[name_x]], levels = unlist_idx)
    
    for (i in 1:length(unlist_idx)) {
      raw_data <- raw_data %>%
        mutate(x_axis_raw = ifelse(
          !!enquo_x == unlist_idx[i], i, x_axis_raw 
        ))
    }
    
    # Obtain raw_y_range_vector
    ylim <- range(raw_data[[name_y]])
    
    # Creation of x-axis label
    Ns <- raw_data %>%
      dplyr::group_by(!!enquo_x) %>%
      dplyr::count()
    Ns$swarmticklabs <- do.call(paste, c(Ns[c(name_x, "n")], sep = "\nN = "))
    
    # (Don't need the below code anymore due to change in implementation)
    # buffer_Ns <- data.frame(Group = "", n = 0, swarmticklabs = "") 
    # Ns <- rbind(Ns)
    
    if(isTRUE(proportional)){
      ## include checks here for data to see if it is proportional data
      proportional_data <- raw_data %>%
        select(!!enquo_x, !!enquo_y, !!enquo_id_col, !!enquo_colour) %>%
        group_by(!!enquo_x) %>%
        summarise(proportion_success = mean(!!enquo_y),
                  y_success = proportion_success/2,
                  y_failure = (1+proportion_success)/2)
      
      control_summary <- proportional_data$proportion_success[1]
      test_summary <- proportional_data$proportion_success[2]
        
    } else {
      
      # Extending ylim for plotting
      ylim[1] <- ylim[1] - (ylim[2]-ylim[1])/25
      ylim[2] <- ylim[2] + (ylim[2]-ylim[1])/25
      
      # Calculation of summary lines
      summaries <- raw_data %>%
        group_by(!!enquo_x) %>%
        summarise(summary_stats = mean(!!enquo_y))
      
      # Only currently works for two-groups, if needed for extended features in future, to be changed
      control_summary <- summaries$summary_stats[1]
      test_summary <- summaries$summary_stats[2]
      
      proportional_data <- NULL
    }
    
    dabest_object <- list(
      raw_data = raw_data,
      proportional_data = proportional_data,
      enquo_x = enquo_x,
      enquo_y = enquo_y,
      enquo_id_col = enquo_id_col,
      enquo_colour = enquo_colour,
      proportional = proportional,
      minimeta = minimeta,
      delta2 = delta2,
      idx = idx,
      is_paired = is_paired,
      is_colour = is_colour,
      paired = paired,
      ci = ci,
      Ns = Ns,
      control_summary = control_summary,
      test_summary = test_summary,
      ylim = ylim
    )
    
    class(dabest_object) <- c("dabest")
    
    return(dabest_object)
  }
  stop()
}
```

## grp_var and bca function for final weighted bca cis
```{r}
#grp variance 
calculate_group_variance <- function(ctrl_var, 
                                     ctrl_N,
                                     test_var, 
                                     test_N) {
  num <- (test_N-1)*test_var + (ctrl_N-1)*ctrl_var
  denom <- test_N + ctrl_N -2
  return(num/denom)
  # return(ctrl_var/ctrl_N + test_var/test_N)
}

#bca function inverse variance method
bca <- function(bootstraps, conf.level = .95){

  if(var(bootstraps)==0){
    lower <- mean(bootstraps)
    upper <- mean(bootstraps)
    return(c(lower, upper))
    }

  if(max(bootstraps)==Inf | min(bootstraps)==-Inf){
    stop("bca() function does not work when some values are infinite")
  }

  low <- (1 - conf.level)/2
  high <- 1 - low
  sims <- length(bootstraps)
  z.inv <- length(bootstraps[bootstraps < mean(bootstraps)])/sims
  z <- qnorm(z.inv)
  U <- (sims - 1) * (mean(bootstraps, na.rm=TRUE) - bootstraps)
  top <- sum(U^3)
  under <- 6 * (sum(U^2))^{3/2}
  a <- top / under
  lower.inv <-  pnorm(z + (z + qnorm(low))/(1 - a * (z + qnorm(low))))
  lower <- quantile(bootstraps, lower.inv, names=FALSE)
  upper.inv <-  pnorm(z + (z + qnorm(high))/(1 - a * (z + qnorm(high))))
  upper <- quantile(bootstraps, upper.inv, names=FALSE)
  return(c(lower, upper))
} 

```

## calculate the last row of boot_result to append the weighted deltas and weighted sum of boostraps
```{r}
boot_weighted_row <- function(boot_result, ci){
  bootstraps <- boot_result$bootstraps
  weights <- boot_result$weight
  
  weighted_result <- Map(function(x, w) x * w,
                         boot_result$bootstraps, boot_result$weight)
  weighted_bootstrap <- Reduce("+", weighted_result)
  
  weighted_difference <- calculate_weighted_delta(weight = boot_result$weight,
                                                  differences = boot_result$difference)
  bca_weighted <- bca(bootstraps = weighted_bootstrap)
  pct_interval <- confinterval(weighted_bootstrap, ci/100)
  boot_last_row <- list(
    control_group = 'Minimeta Overall Test',
    test_group = 'Minimeta Overall Test',
    bootstraps = list(as.vector(weighted_bootstrap)),
    nboots = length(weighted_bootstrap),
    bca_ci_low = bca_weighted[1],
    bca_ci_high = bca_weighted[2],
    pct_ci_low = pct_interval[1],
    pct_ci_high = pct_interval[2],
    ci = ci,
    difference = weighted_difference,
    weight = 1)
  return(boot_last_row)
}
```

## weighted delta and confidence interval function
```{r}
calculate_weighted_delta <- function(weight, differences) {
  denom <- sum(weight)
  num <- sum(weight*differences)
  return(num / denom)
}

confinterval <- function(vector, ci_decimal){
  sample_mean <- mean(vector)
  standard_error <- sd(vector) / sqrt(length(vector))
  z <- qnorm(1 - (1 - ci_decimal) / 2)

  margin_of_error <- z * standard_error
  confidence_interval <- c(sample_mean - margin_of_error, 
                           sample_mean + margin_of_error)
  
  return(confidence_interval)
}

var_w_df <- function(measurement, size){
  df <- size - 1
  # Calculate the variance with specified degrees of freedom
  var <- (sum((measurement - mean(measurement))^2) / df)
  
  return(var)
}
```

# Bootstrap helper functions
```{r}
effsize_boot <- function(
    data, 
    effect_size_func, 
    reps = 5000, 
    paired = FALSE
    ){
  
  s <- c(rep(1, length(data$control)),
         rep(2, length(data$test)))

  bootboot <- function(d, indices, paired) {
    c <- d[indices[s == 1]]
    t <- d[indices[s == 2]]

    return(effect_size_func(c, t, paired))
  }

  b <- boot(
    c(data$control, data$test),
    statistic = bootboot,
    R = reps,
    strata = s,
    paired = paired
    )

  return(b)
}

bootstrap <- function(
    dabest_obj,
    effect_size_func,
    seed = 12345,
    reps = 5000,
    boot_labs
    ){
  
  boot_result <- tibble()
  
  raw_data <- dabest_obj$raw_data
  idx <- dabest_obj$idx
  
  if (isFALSE(is.list(idx))) {
    idx <- list(idx)
  }
  enquo_x <- dabest_obj$enquo_x
  enquo_y <- dabest_obj$enquo_y
  ci <- dabest_obj$ci
  paired <- dabest_obj$paired
  is_paired <- dabest_obj$is_paired
  is_colour <- dabest_obj$is_colour
  
  quoname_x <- as_name(enquo_x)
  quoname_y <- as_name(enquo_y)
  delta_x_labels <- list()
  delta_y_labels <- boot_labs
  
  minimeta <- dabest_obj$minimeta
  delta2 <- dabest_obj$delta2
  
  if (isFALSE(is_paired) || isTRUE(paired == "baseline")) {
    for (group in idx) {
      group_length <- length(group)
      
      ctrl_tibble <- raw_data %>% 
        filter(!!enquo_x == !!group[1])
      ctrl_measurement <- ctrl_tibble[[quoname_y]]
      
      tests <- group[2:group_length]
      
      ctrl_size <- length(ctrl_measurement)
      ctrl_var <- var_w_df(ctrl_measurement, ctrl_size)
      
      
      for (test_group in tests) {
        test_tibble <- raw_data %>%
          filter(!!enquo_x == !!test_group)
        
        test_measurement <- test_tibble[[quoname_y]]
        
        xlabels <- paste(test_group, group[1], sep="\nminus\n")
        delta_x_labels <- append(delta_x_labels, xlabels)
        
        control_test_measurement <- list(control = ctrl_measurement,
                                         test = test_measurement)
        
        
        test_size <- length(test_measurement)
        test_var <- var_w_df(test_measurement, test_size)
        
        grp_var <- calculate_group_variance(ctrl_var = ctrl_var,
                                            ctrl_N = ctrl_size,
                                            test_var = test_var,
                                            test_N = test_size)
        
        weight <- 1/grp_var
          
        set.seed(seed)
        
        boots <- effsize_boot(data = control_test_measurement,
                              effect_size_func = effect_size_func,
                              reps = reps,
                              paired = is_paired)
        
        if (ci < 0 | ci > 100) {
          err_string <- str_interp("`ci` must be between 0 and 100, not ${ci}")
          stop(err_string)
        }
        
        bootci <- boot.ci(boots, conf=ci/100, type = c("perc","bca"))
        
        boot_row <- list(
          control_group = group[1],
          test_group = test_group,
          bootstraps = list(as.vector(boots$t)),
          nboots = length(boots$t),
          bca_ci_low = bootci$bca[4],
          bca_ci_high = bootci$bca[5],
          pct_ci_low = bootci$percent[4],
          pct_ci_high = bootci$percent[5],
          ci = ci,
          difference = boots$t0,
          weight = weight
        )
        boot_result <- bind_rows(boot_result, boot_row)
      }
    }
  } else {
    for (group in idx) {
      group_length <- length(group)
      for (i in 1:(group_length-1)) {
        control_group <- group[i]
        test_group <- group[i+1]
        
        ctrl_tibble <- raw_data %>% 
          filter(!!enquo_x == !!control_group)
        ctrl_measurement <- ctrl_tibble[[quoname_y]]
        
        test_tibble <- raw_data %>% 
          filter(!!enquo_x == !!test_group)
        test_measurement <- test_tibble[[quoname_y]]
        
        xlabels <- paste(test_group, control_group, sep="\nminus\n")
        delta_x_labels <- append(delta_x_labels, xlabels)
        
        control_test_measurement <- list(control = ctrl_measurement,
                                         test = test_measurement)
        #add weights column
        ctrl_size <- length(ctrl_measurement)
        ctrl_var <- var_w_df(ctrl_measurement, ctrl_size)
        test_size <- length(test_measurement)
        test_var <- var_w_df(test_measurement, test_size)
        grp_var <- calculate_group_variance(ctrl_var = ctrl_var,
                                            ctrl_N = ctrl_size,
                                            test_var = test_var,
                                            test_N = test_size)
        
        weight <- 1/grp_var
        
        set.seed(seed)
        
        boots <- effsize_boot(data = control_test_measurement,
                              effect_size_func = effect_size_func,
                              reps = reps,
                              paired = is_paired)
        
        if (ci < 0 | ci > 100) {
          err_string <- str_interp("`ci` must be between 0 and 100, not ${ci}")
          stop(err_string)
        }
        
        bootci <- boot.ci(boots, conf=ci/100, type = c("perc","bca"))
        
        boot_row <- list(
          control_group = group[1],
          test_group = test_group,
          bootstraps = list(as.vector(boots$t)),
          nboots = length(boots$t),
          bca_ci_low = bootci$bca[4],
          bca_ci_high = bootci$bca[5],
          pct_ci_low = bootci$percent[4],
          pct_ci_high = bootci$percent[5],
          ci = ci,
          difference = boots$t0,
          weight = weight
        )
        boot_result <- bind_rows(boot_result, boot_row)
      }
    }
  }
  if (isTRUE(minimeta)){
    boot_last_row <- boot_weighted_row(boot_result = boot_result, ci)
    boot_result <- bind_rows(boot_result, boot_last_row)
    delta_x_labels <- append(delta_x_labels, "Weighted Delta")
    }
  
  out <- list(raw_data = raw_data,
              idx = idx,
              delta_x_labels = delta_x_labels,
              delta_y_labels = delta_y_labels,
              raw_data = raw_data,
              is_paired = is_paired,
              is_colour = is_colour,
              paired = paired,
              Ns = dabest_obj$Ns,
              control_summary = dabest_obj$control_summary,
              test_summary = dabest_obj$test_summary,
              ylim = dabest_obj$ylim,
              enquo_x = dabest_obj$enquo_x,
              enquo_y = dabest_obj$enquo_y,
              enquo_id_col = dabest_obj$enquo_id_col,
              enquo_colour = dabest_obj$enquo_colour,
              proportional = dabest_obj$proportional,
              minimeta = minimeta,
              delta2 = dabest_obj$delta2,
              proportional_data = dabest_obj$proportional_data,
              boot_result = boot_result)
  
  return(out)
}
```

# Main effect_size functions
```{r}
mean_diff <- function(dabest_obj) {
  
  effect_size_func <- function(control, test, paired) {
    if (identical(paired, FALSE)) {
      return(mean(test) - mean(control))
    }
    return(mean(test - control))
  }
  
  is_paired <- dabest_obj$is_paired
  
  if(is_paired){
    return(bootstrap(dabest_obj, effect_size_func, boot_labs = "Paired\nmean difference"))
  }
  return(bootstrap(dabest_obj, effect_size_func, boot_labs = "Mean difference"))
}

median_diff <- function(dabest_obj) {
  
  effect_size_func <- function(control, test, paired) {
    if (identical(paired, FALSE)) {
      return(median(test) - median(control))
    }
    return(median(test - control))
  }
  
  is_paired <- dabest_obj$is_paired
  
  if(is_paired){
    return(bootstrap(dabest_obj, effect_size_func, boot_labs = "Paired\nmedian difference"))
  }
  return(bootstrap(dabest_obj, effect_size_func, boot_labs = "Median difference"))
}

cohens_d <- function(dabest_obj) {
  
  effect_size_func <- function(control, test, paired) {
    return(effsize::cohen.d(test, control, paired=paired)$estimate)
  }
  
  return(bootstrap(dabest_obj, effect_size_func, boot_labs = "Cohen's d"))
}

hedges_g <- function(dabest_obj) {
  
  cohens_d_ <- function(control, test, paired) {
    return(effsize::cohen.d(test, control, paired=paired)$estimate)
  }
  
  effect_size_func <- function(control, test, paired) {
    cd <- cohens_d_(test, control, paired=paired)
    corr.factor <- -hedges_correction(test, control)
    return(cd * corr.factor)
  }
  
  return(bootstrap(dabest_obj, effect_size_func, boot_labs = "Hedges' g"))
}

cliffs_delta <- function(dabest_obj) {
  
  effect_size_func <- function(control, test, paired=NA) {
    return(effsize::cliff.delta(test, control)$estimate)
  }
  
  return(bootstrap(dabest_obj, effect_size_func, boot_labs = "Cliffs' delta"))
}

cohens_h <- function(dabest_obj){
  
  effect_size_func <- function(control, test, paired) {
    #remove nas and nulls later on
    prop_control <- mean(control)
    prop_test <- mean(test)

    # Arcsine transformation
    phi_control <- 2 * asin(sqrt(prop_control))
    phi_test <- 2 * asin(sqrt(prop_test))
    result <- phi_test - phi_control
    return(result)
  }
  
  return(bootstrap(dabest_obj, effect_size_func, boot_labs = "Cohen's h"))
}

hedges_correction <- function(x1, x2) {

  n1 <- length(x1)
  n2 <- length(x2)

  deg.freedom <- n1 + n2 - 2
  numer       <- gamma(deg.freedom/2)
  denom0      <- gamma((deg.freedom - 1) / 2)
  denom       <- sqrt((deg.freedom / 2)) * denom0

  if (is.infinite(numer) | is.infinite(denom)) {
    # Occurs when df is too large.
    # Applies Hedges and Olkin's approximation.
    df.sum <- n1 + n2
    denom <- (4 * df.sum) - 9
    out <- 1 - (3 / denom)
  } else out <- numer / denom

  return(out)
}
```

# float_contrast/non_float_contrast themes
```{r}
# Theme for left-right graph
float_contrast_theme <- 
  theme(plot.margin = ggplot2::unit(c(5.5, 0, 5.5, 0), "pt"),
        axis.line.x = ggplot2::element_blank(), 
        axis.title.x = ggplot2::element_blank(), 
        axis.ticks.x = ggplot2::element_blank(),
        axis.title.x.bottom = ggplot2::element_blank(),
        legend.title=element_blank())

# Theme for top-down graph
non_float_contrast_theme <- 
  theme(axis.line.x = ggplot2::element_blank(), 
        axis.title.x = ggplot2::element_blank(), 
        axis.ticks.x = ggplot2::element_blank(),
        axis.title.x.bottom = ggplot2::element_blank(),
        axis.title.y = element_text(size = 10),
        legend.title=element_blank())

```

# helper math stats tool functions
```{r}
sigmoid <- function(x_from, factor, y_from, y_to, smooth = 5.5, n = 300) {
  x <- seq(-smooth, smooth, length = n)
  y <- exp(x) / (exp(x) + 1)
  out <- data.frame(x = (x + smooth) / (smooth * 2) * factor + x_from,
                    y = y * (y_to - y_from) + y_from)
}

flipped_sig <- function(x_from, factor, y_from, y_to, smooth = 5.5, n = 300) {
  x <- seq(-smooth, smooth, length = n)
  y <- -exp(-x) / (exp(-x) + 1)
  out <- data.frame(x = (x + smooth) / (smooth * 2) * factor + x_from,
                    y = y * (y_to - y_from) + y_to)
}
```

# df creation functions
```{r}
# Function for creation of df for tuftelines plot
df_for_tufte <- function(raw_data, enquo_x, enquo_y, proportional){
  tufte_lines_df <- raw_data %>%
    dplyr::group_by(!!enquo_x) %>%
    dplyr::summarize(mean = mean(!!enquo_y),
                     median = median(!!enquo_y),
                     sd = sd(!!enquo_y),
                     lower_quartile = stats::quantile(!!enquo_y)[2],
                     upper_quartile = stats::quantile(!!enquo_y)[4])
  
  if(isTRUE(proportional)){
    tufte_lines_df <- tufte_lines_df %>%
      dplyr::mutate(sd = sd/10)
  }
  tufte_lines_df <- tufte_lines_df %>%
    dplyr::mutate(lower_sd = mean - sd, upper_sd = mean + sd)
  
  return(tufte_lines_df)
}

create_dfs_for_sankey <- function(float_contrast = FALSE, 
                                 raw_data, 
                                 proportional_data, 
                                 enquo_id_col, 
                                 x_axis_raw, 
                                 ind = 1,
                                 scale_factor_sig = 0.8,
                                 gap
                                 ) {
  ind <- 1
  bar_width <- ifelse(float_contrast, 0.15, 0.10)
  means_c_t <- proportional_data$proportion_success
  #for() will use for loops for multiple plot groups
  success_success <- raw_data %>%
    group_by(!!enquo_id_col) %>%
    summarise(success_change = 
                any(Success == 1 & Group == "Control1") & 
                any(Success == 1 & Group == "Test1")) %>%
    filter(success_change) %>%
    summarise(C1T1 = n()/N)
  failure_failire <- raw_data %>%
    group_by(!!enquo_id_col) %>%
    summarise(success_change = 
                any(Success == 0 & Group == "Control1") & 
                any(Success == 0 & Group == "Test1")) %>%
    filter(success_change) %>%
    summarise(C1T1F = n()/N)
  
  # find values for lower flow success to failure flow
  ss <- success_success$C1T1[1]
  value_start1 <- success_success$C1T1[1] - gap/8
  value_start2 <- means_c_t[1]- gap/2 - gap/8
  value_end1 <- means_c_t[2] + gap/2 +gap/8
  value_end2 <- 1- failure_failire$C1T1F[1] + gap/8
  
  
  # find values for upper flppied flow success to failure flow
  flow_start1 <- 1- failure_failire$C1T1F[1]
  flow_end1 <- means_c_t[2] - gap/2
  flow_start2 <- means_c_t[1] + gap/2
  flow_end2 <- success_success$C1T1[1]
  
  # form dataframes from sigmoid/ flippedSig functions and the rectangles, later fit into sankeyflow
  sig1 <- sigmoid(ind + bar_width, scale_factor_sig, value_start1, value_end1)
  sig2 <- sigmoid(ind + bar_width, scale_factor_sig, value_start2, value_end2)
  sig1 <- arrange(sig1, desc(x))
  sig3 <- flipped_sig(ind + bar_width, scale_factor_sig, flow_start1, flow_end1)
  sig4 <- flipped_sig(ind + bar_width, scale_factor_sig, flow_start2, flow_end2)
  sig4 <- arrange(sig4, desc(x))
  data_for_flow1 <- rbind(sig2, sig1)
  data_for_flow2 <- rbind(sig3, sig4)
  data_for_rect_top <- data.frame(
    x = c(x_axis_raw, rev(x_axis_raw)), 
    y = c(1, 1, rep(flow_start1, 2)))
  data_for_rect_bot <- data.frame(
    x = c(x_axis_raw, rev(x_axis_raw)), 
    y = c(rep(ss,2), 0, 0))
  
  #prepare data for bargraphs of paired proportional data
  data_for_bars <- proportional_data
  
  
  list_of_dfs <- list(
    flow1 = data_for_flow1,
    flow2 = data_for_flow2, 
    rect_top = data_for_rect_top, 
    rect_bot = data_for_rect_bot,
    bars = proportional_data
  )
  list_of_dfs
}

create_dfs_for_xaxis_redraw <- function(idx) {
  x_axis_pointer <- 0
  xaxis_line_x_vector <- c()
  xaxis_line_xend_vector <- c()
  xaxis_ticks_x_vector <- c()
  
  for (j in 1:length(idx)) {
    # calculate xaxis line x coords
    x_coord <- x_axis_pointer + 1
    xaxis_line_x_vector <- append(xaxis_line_x_vector, x_coord)
    xend_coord <- x_axis_pointer + length(idx[[j]])
    xaxis_line_xend_vector <- append(xaxis_line_xend_vector, xend_coord)
    
    # calculate xaxis ticks x coords
    for (k in 1:length(idx[[j]])) {
      x_coord <- x_axis_pointer + k
      xaxis_ticks_x_vector <- append(xaxis_ticks_x_vector, x_coord)
    }
    x_axis_pointer <- x_axis_pointer + length(idx[[j]])
  }
  
  dfs_for_xaxis_redraw <- list(
    df_for_line = data.frame(x = xaxis_line_x_vector,
                             xend = xaxis_line_xend_vector),
    df_for_ticks = data.frame(x = xaxis_ticks_x_vector)
  )
  
  return(dfs_for_xaxis_redraw)
}

create_rawplot_components <- function(proportional, 
                                   is_paired, 
                                   float_contrast) {
  main_plot_type <- ""
  is_summary_lines <- TRUE
  is_tufte_lines <- TRUE
  
  if (isTRUE(proportional)) {
    if (isFALSE(is_paired)) {
      main_plot_type <- "unpaired proportions"
      if(isTRUE(float_contrast)){
          is_summary_lines <- TRUE
      } else {
          is_summary_lines <- FALSE
      }
    } else {
      main_plot_type <- "sankey"
      is_summary_lines <- FALSE
    }
  } else {
    if (isFALSE(is_paired)) {
      main_plot_type <- "swarmplot"
      if(isTRUE(float_contrast)){
          is_summary_lines <- TRUE
      } else {
          is_summary_lines <- FALSE
      }
    } else {
      main_plot_type <- "slope"
      is_tufte_lines <- FALSE
      if(isTRUE(float_contrast)){
        is_summary_lines <- TRUE
      } else {
        is_summary_lines <- FALSE
      }
    }
  }
  
  plot_component <- list(
    main_plot_type = main_plot_type,
    is_summary_lines = is_summary_lines,
    is_tufte_lines = is_tufte_lines
  )
  return(plot_component)
}
```

```{r}
assign_plot_kwargs <- function(plot_kwargs) {
  colour_col <- NULL
  swarm_label <- NULL
  contrast_label <- NULL
  custom_palette <- "d3"
  swarm_ylim <- NULL
  contrast_ylim <- NULL
  delta2_ylim <- NULL
  delta2_label <- NULL
  
  if(isFALSE(is.null(plot_kwargs$colour_col))) {
    colour_col <- plot_kwargs$colour_col
  }
  if(isFALSE(is.null(plot_kwargs$swarm_label))) {
    swarm_label <- plot_kwargs$swarm_label
  }
  if(isFALSE(is.null(plot_kwargs$contrast_label))) {
    contrast_label <- plot_kwargs$contrast_label
  }
  if(isFALSE(is.null(plot_kwargs$custom_palette))) {
    custom_palette <- plot_kwargs$custom_palette
  }
  if(isFALSE(is.null(plot_kwargs$swarm_ylim))) {
    swarm_ylim <- plot_kwargs$swarm_ylim
  }
  if(isFALSE(is.null(plot_kwargs$contrast_ylim))) {
    contrast_ylim <- plot_kwargs$contrast_ylim
  }
  if(isFALSE(is.null(plot_kwargs$delta2_ylim))) {
    delta2_ylim <- plot_kwargs$delta2_ylim
  }
  if(isFALSE(is.null(plot_kwargs$delta2_label))) {
    delta2_label <- plot_kwargs$delta2_label
  }
  return(list(
    colour_col = colour_col,
    swarm_label = swarm_label,
    contrast_label = contrast_label,
    custom_palette = custom_palette,
    swarm_ylim = swarm_ylim,
    contrast_ylim = contrast_ylim,
    delta2_ylim = delta2_ylim,
    delta2_label = delta2_label
  ))
}
```

# custom proportionbar geom
```{r}
"%||%" <- function(a, b) {
  if (!is.null(a)) a else b
}

draw_panel_proportion_bar <- function(data, panel_scales, coord) {
  coords <- coord$transform(data, panel_scales) 
  
  failure_bar <- rectGrob(x = coords$x,
                          y = 1,
                          width = coords$width,
                          height = 1 - coords$y,
                          default.units = "native",
                          just = c("center", "top"),
                          gp = gpar(col = coords$colour,
                                    fill = "white",
                                    lwd = coords$size * .pt))
  
  success_bar <- rectGrob(x = coords$x,
                          y = 0,
                          width = coords$width,
                          height = coords$y,
                          default.units = "native",
                          just = c("center", "bottom"),
                          gp = gpar(col = coords$colour,
                                    fill = alpha(coords$fill, coords$alpha),
                                    lwd = coords$size * .pt))
  
  gTree(children = gList(failure_bar, success_bar))
  
}

GeomProportionBar <- ggproto("GeomProportionBar", GeomRect,
                      required_aes = c("x", "y"),
                      non_missing_aes = c("xmin", "xmax", "ymin", "ymax"),
                      default_aes = aes(colour = NA,
                                        width = 0.2,
                                        fill = "grey35",
                                        alpha = NA,
                                        lwd = 2,
                                        size = 0.7),
                      
                      set_up_data = function(data, params) {
                        data$width <- data$width %||% params$width
                        data <- transform(data,
                          ymin = pmin(y, 0), ymax = pmax(y, 1),
                          xmin = x - width, xmax = x + width,
                          width = width)
                        data
                      },
                      
                      draw_key = draw_key_polygon,
                      draw_panel = draw_panel_proportion_bar)

geom_proportionbar <- function(mapping = NULL, data = NULL, 
                               stat = "identity", position = "stack", 
                               ...,
                               show.legend = NA, 
                               na.rm = FALSE, 
                               inherit.aes = TRUE) {
  layer(data = data, 
        mapping = mapping,
        stat = stat,
        geom = GeomProportionBar,
        position = position,
        show.legend = show.legend,
        inherit.aes = inherit.aes,
        params = list(
          na.rm = na.rm, 
          ...))
}
```

# create sankey diagrams
```{r}
# sankey bars
draw_panel_sankey_bar <- function(data, panel_scales, coord) {
  coords <- coord$transform(data, panel_scales) 
  
  failure_bar <- rectGrob(x = coords$x,
                          y = coords$yfailure + coords$gap/4,
                          width = coords$width,
                          height = 1 - coords$proportionsuccess - coords$gap/2,
                          gp = gpar(col = coords$col_failure,
                                    fill = alpha(coords$fill_failure, coords$alpha),
                                    lwd = coords$size * .pt))
  
  success_bar <- rectGrob(x = coords$x,
                          y = coords$ysuccess - coords$gap/4,
                          width = coords$width,
                          height = coords$proportionsuccess - coords$gap/2,
                          gp = gpar(col = coords$col_success,
                                    fill = alpha(coords$fill_success, coords$alpha),
                                    lwd = coords$size * .pt))
  
  gTree(children = gList(failure_bar, success_bar))
  
}

GeomSankeyBar <- ggproto("GeomSankeyBar", Geom,
                      required_aes = c("x", "yfailure", "ysuccess", "proportionsuccess"),
                      default_aes = aes(col = NA,
                                        width = 0.2,
                                        col_failure = "#818181",
                                        col_success = "#db6159",
                                        fill_failure = "#818181",
                                        fill_success = "#db6159",
                                        alpha = 1,
                                        lwd = 2,
                                        size = 0.7,
                                        gap = 0.05),
                      draw_key = draw_key_rect,
                      draw_panel = draw_panel_sankey_bar)

geom_sankeybar <- function(mapping = NULL, data = NULL, stat = "identity", 
                        position = "identity", show.legend = NA, 
                        na.rm = FALSE, inherit.aes = TRUE, ...) {
  layer(data = data, 
        mapping = mapping,
        stat = stat,
        geom = GeomSankeyBar,
        position = position,
        show.legend = show.legend,
        inherit.aes = inherit.aes,
        params = list(na.rm = na.rm, ...))
}

# sankey flows
draw_panel_sankey_flow <- function(data, panel_scales, coord) {
  coords <- coord$transform(data, panel_scales) 
  
  flow <- polygonGrob(x = coords$x,
                      y = coords$y,
                      gp = gpar(col = coords$fillcol,
                                fill = coords$fillcol,
                                alpha = coords$alpha))

}

GeomSankeyFlow <- ggproto("GeomSankeyFlow", Geom,
                          required_aes = c("x", "y"),
                          default_aes = aes(fillcol = "gray50",
                                            alpha = 0.8),
                          draw_key = draw_key_polygon,
                          draw_panel = draw_panel_sankey_flow)

geom_sankeyflow <- function(mapping = NULL, data = NULL, stat = "identity", 
                           position = "identity", show.legend = NA, 
                           na.rm = FALSE, inherit.aes = TRUE, ...) {
        layer(data = data, 
              mapping = mapping,
              stat = stat,
              geom = GeomSankeyFlow,
              position = position,
              show.legend = show.legend,
              inherit.aes = inherit.aes,
              params = list(na.rm = na.rm, ...))
}
```

## plot slopegraph
```{r}
plot_slopegraph <- function(dabest_effectsize_obj) {
  raw_data <- dabest_effectsize_obj$raw_data
  
  enquo_x = dabest_effectsize_obj$enquo_x
  enquo_y = dabest_effectsize_obj$enquo_y
  enquo_id_col = dabest_effectsize_obj$enquo_id_col
  enquo_colour = dabest_effectsize_obj$enquo_colour
  
  name_x <- as_name(enquo_x)
  name_y <- as_name(enquo_y)
  
  idx = dabest_effectsize_obj$idx
  
  raw_plot <- ggplot()
  slopegraph_params <- list(linewidth = 0.3, alpha = 0.5)
  
  for(subplot_groups in idx) {
    # Assign subplot.
    subplot <- dplyr::filter(raw_data, !!enquo_x %in% subplot_groups)

    subplot[[name_x]] <-
      subplot[[name_x]] %>%
      factor(subplot_groups, ordered = TRUE)

    slopegraph_params[["data"]] <- subplot

    # Assign aesthetic mappings.
    if(rlang::quo_is_null(enquo_colour)) {
      slopegraph_aes <- ggplot2::aes(x_axis_raw, !!enquo_y,
                            group = !!enquo_id_col)
    } else {
      slopegraph_aes <- ggplot2::aes(x_axis_raw, !!enquo_y,
                            group = !!enquo_id_col,
                            col = !!enquo_colour)
    }

    slopegraph_params[["mapping"]] <- slopegraph_aes

    # Create slopegraph
    raw_plot <-
      raw_plot +
      do.call(ggplot2::geom_line, slopegraph_params)
  }
  
  return(raw_plot)
}
```

# raw plot function
```{r}
plot_raw <- function(dabest_effectsize_obj, float_contrast, plot_kwargs) {
  enquo_x = dabest_effectsize_obj$enquo_x
  enquo_y = dabest_effectsize_obj$enquo_y
  enquo_id_col = dabest_effectsize_obj$enquo_id_col
  enquo_colour = dabest_effectsize_obj$enquo_colour
  proportional = dabest_effectsize_obj$proportional
  minimeta = dabest_effectsize_obj$minimeta
  delta2 = dabest_effectsize_obj$delta2
  proportional_data = dabest_effectsize_obj$proportional_data
  
  raw_data <- dabest_effectsize_obj$raw_data
  Ns <- dabest_effectsize_obj$Ns
  raw_y_range_vector <- dabest_effectsize_obj$ylim
  
  raw_y_max <- raw_y_range_vector[2]
  raw_y_min <- raw_y_range_vector[1]
  if(isFALSE(float_contrast) && isFALSE(proportional)) {
    raw_y_min <- raw_y_min - (raw_y_max - raw_y_min)/15
  }
  raw_y_mean <- raw_y_max - raw_y_min
  
  test_summary <- dabest_effectsize_obj$test_summary
  control_summary <- dabest_effectsize_obj$control_summary
  is_paired <- dabest_effectsize_obj$is_paired
  is_colour <- dabest_effectsize_obj$is_colour
  
  idx <- dabest_effectsize_obj$idx
  raw_x_max = length(unlist(idx))
  x_axis_raw <- c(seq(1, raw_x_max,1))
  
  # Extend x_axis if minimeta/deltadelta is being plotted.
  if(isTRUE(minimeta) || isTRUE(delta2)) {
    raw_x_max <- raw_x_max + 2
  }
  
  effsize_type <- dabest_effectsize_obj$delta_y_labels
  
  # Check if multiplot.
  if(length(unlist(idx)) >= 3) {
    float_contrast = FALSE
  }
  
  #### Rawplot Building ####
  plot_components <- create_rawplot_components(proportional, is_paired, float_contrast)
  main_plot_type <- plot_components$main_plot_type
  is_summary_lines <- plot_components$is_summary_lines
  is_tufte_lines <- plot_components$is_tufte_lines
  
  if(main_plot_type == "sankey"){
    sankey_bar_gap <- 0.02
    sankey_df <- create_dfs_for_sankey(float_contrast = float_contrast, 
                                       raw_data = raw_data,
                                       proportional_data = proportional_data,
                                       enquo_id_col = enquo_id_col,
                                       x_axis_raw = x_axis_raw,
                                       gap = sankey_bar_gap)
    flow1 <- sankey_df$flow1
    flow2 <- sankey_df$flow2
    rect_top <- sankey_df$rect_top
    rect_bot <- sankey_df$rect_bot
    bars <- sankey_df$bars
  }
  
  if(as_label(enquo_colour) == "NULL" && main_plot_type != "slope") {
    enquo_colour <- enquo_x
  }
  
  bar_width <- ifelse(float_contrast, 0.15, 0.10)
  
  #### Initialise raw_plot & Add main_plot_type component ####
  raw_plot <- switch(
    main_plot_type,
    
    "swarmplot" =
      ggplot() +
      geom_beeswarm(data = raw_data, 
                    aes(x = x_axis_raw, 
                        y = !!enquo_y, 
                        colour = !!enquo_colour),
                    cex = 2),
    
    "slope" = 
      plot_slopegraph(dabest_effectsize_obj),
    
    "unpaired proportions" = 
      ggplot() +
      geom_proportionbar(data = proportional_data,
                         aes(x = x_axis_raw,
                             y = proportion_success,
                             colour = !!enquo_x, 
                             fill = !!enquo_x,
                             width = bar_width)),
    
    "sankey" =
      ggplot() +
      geom_sankeyflow(data = flow1, 
                      aes(x = x, y = y, fillcol = "#db6159")) +
      geom_sankeyflow(data = flow2, 
                      aes(x = x, y = y, fillcol = "#818181")) +
      geom_sankeyflow(data = rect_top, 
                      aes(x = x, y = y, fillcol = "#818181")) +
      geom_sankeyflow(data = rect_bot, 
                      aes(x = x, y = y, fillcol = "#db6159")) +
      geom_sankeybar(data = bars, 
                     aes(x = x_axis_raw,
                         ysuccess = y_success, 
                         yfailure = y_failure, 
                         proportionsuccess = proportion_success, 
                         width = bar_width,
                         gap = sankey_bar_gap))
  )
  
  #### Add scaling Component ####
  raw_plot <- raw_plot +
    theme_classic() +
    coord_cartesian(ylim = c(raw_y_min, raw_y_max),
                    xlim = c(0.6,raw_x_max+0.5),
                    expand = FALSE,
                    clip = "off") +
    scale_x_continuous(breaks = c(x_axis_raw),
                       labels = Ns$swarmticklabs)
  
  #### Add summary_lines component ####
  if(isTRUE(is_summary_lines)) {
    raw_plot <- raw_plot +
      geom_segment(colour = "black",linewidth = 0.3,
                   aes(x = 1, 
                       xend = raw_x_max+0.5,
                       y = control_summary, 
                       yend = control_summary)) +
      geom_segment(colour = "black", linewidth = 0.3,
                   aes(x = 2, 
                       xend = raw_x_max+0.5, 
                       y = test_summary, 
                       yend = test_summary))
  }
  
  #### Add tufte_lines component ####
  if(isTRUE(is_tufte_lines)) {
    tufte_lines_df <- df_for_tufte(raw_data, enquo_x, enquo_y, proportional)
    if(main_plot_type == "sankey"){
      tufte_gap_value <- sankey_bar_gap
    } else {
      tufte_gap_value <- ifelse(proportional, min(tufte_lines_df$mean)/20, min(tufte_lines_df$mean)/50)
      tufte_gap_value <- ifelse(float_contrast, tufte_gap_value, tufte_gap_value*2)
    }
    tufte_side_adjust_value <- ifelse(proportional, 0, 0.10)
    
    row_num <- max(x_axis_raw)
    row_ref <- c(seq(1, row_num, 1)) + tufte_side_adjust_value
    x_ref <- row_ref
    
    y_top_t <-list(y = tufte_lines_df$mean + tufte_gap_value,  
                   yend = tufte_lines_df$upper_sd)
    y_bot_t <-list(y = tufte_lines_df$mean - tufte_gap_value, 
                   yend = tufte_lines_df$lower_sd) 
    if (isTRUE(str_detect(effsize_type, "edian"))) {
      y_top_t <-list(y = tufte_lines_df$median + tufte_gap_value,  
                     yend = tufte_lines_df$upper_quartile)
      y_bot_t <-list(y = tufte_lines_df$mean - tufte_gap_value, 
                     yend = tufte_lines_df$lower_quartile) 
    }
    
    # to change: temporary fix for tufte lines black for proportional graphs
    if(isTRUE(proportional) | isTRUE(is_colour)) {
      raw_plot <- raw_plot +
        geom_segment(data = tufte_lines_df, 
                     linewidth = 0.8,
                     colour = "black",
                     aes(x = row_ref, 
                         xend = row_ref, 
                         y = y_bot_t$y, 
                         yend = y_bot_t$yend,
                         colour = !!enquo_x),
                     lineend = "square") +
        geom_segment(data = tufte_lines_df, 
                     linewidth = 0.8,
                     colour = "black",
                     aes(x = row_ref, 
                         xend = row_ref, 
                         y = y_top_t$y, 
                         yend = y_top_t$yend,
                         colour = !!enquo_x),
                     lineend = "square")
    } else {
      raw_plot <- raw_plot +
        geom_segment(data = tufte_lines_df, linewidth = 0.8,
                     aes(x = row_ref, 
                         xend = row_ref, 
                         y = y_bot_t$y, 
                         yend = y_bot_t$yend,
                         colour = !!enquo_x),
                     lineend = "square") +
        geom_segment(data = tufte_lines_df, linewidth = 0.8,
                     aes(x = row_ref, 
                         xend = row_ref, 
                         y = y_top_t$y, 
                         yend = y_top_t$yend,
                         colour = !!enquo_x),
                     lineend = "square")
    }
  }
  
  #### Remove x-axis and redraw x_axis component ####
  if(isTRUE(float_contrast)) {
    raw_plot <- raw_plot +
      float_contrast_theme +
      geom_segment(linewidth = 0.45, 
                   color = "black",
                   aes(x = 0.6, xend = raw_x_max+0.2, y = raw_y_min, yend = raw_y_min))
    
  } else {
    # Obtain dfs for xaxis redraw
    dfs_for_xaxis_redraw <- create_dfs_for_xaxis_redraw(idx)
    df_for_line <- dfs_for_xaxis_redraw$df_for_line
    df_for_ticks <- dfs_for_xaxis_redraw$df_for_ticks
    
    raw_plot <- raw_plot +
      non_float_contrast_theme +
      # Redraw xaxis line
      geom_segment(data = df_for_line,
                   linewidth = 0.5,
                   lineend = "square", 
                   color = "black",
                   aes(x = x, 
                       xend = xend, 
                       y = raw_y_min + raw_y_mean/20, 
                       yend = raw_y_min + raw_y_mean/20))  +
      # Redraw xaxis ticks
      geom_segment(data = df_for_ticks,
                   linewidth = 0.5,
                   lineend = "square", 
                   color = "black",
                   aes(x = x, 
                       xend = x, 
                       y = raw_y_min + raw_y_mean/20, 
                       yend = raw_y_min))
  }
  
  #### Add y_labels component ####
  if(isTRUE(proportional)){
    raw_plot <- raw_plot +
      labs(y = "proportion of success")
  } else {
    raw_plot <- raw_plot +
      labs(y = "value")
  }
  
  return(raw_plot)
}
```

# custom violin & boot_ci geoms
```{r}
draw_group_halfviolin <- function(data, panel_scales, coord) {
  coords <- coord$transform(data, panel_scales) 
  
  first_row <- coords[1, , drop = FALSE]
  
  violin <- polygonGrob(x = coords$x,
                        y = coords$y,
                        gp = gpar(col = first_row$colour,
                                  fill = alpha(first_row$fill, first_row$alpha)))

}

GeomHalfViolin <- ggproto("GeomHalfViolin", Geom,
                          required_aes = c("x", "y"),
                          default_aes = aes(colour = NA, 
                                            fill = "grey50",
                                            alpha = 0.8),
                          draw_key = draw_key_point,
                          draw_group = draw_group_halfviolin)

geom_halfviolin <- function(mapping = NULL, data = NULL, stat = "identity", 
                           position = "identity", show.legend = NA, 
                           na.rm = FALSE, inherit.aes = TRUE, ...) {
        layer(data = data, 
              mapping = mapping,
              stat = stat,
              geom = GeomHalfViolin,
              position = position,
              show.legend = show.legend,
              inherit.aes = inherit.aes,
              params = list(na.rm = na.rm, ...))
}

draw_panel_boot_ci <- function(data, panel_scales, coord) {
  coords <- coord$transform(data, panel_scales) 
        
  ci_line <- segmentsGrob(x0 = coords$x,
                          x1 = coords$x,
                          y0 = coords$ymin,
                          y1 = coords$ymax,
                          gp = gpar(lwd = coords$linesize * .pt,
                                    lineend = coords$lineend))
  
  ci_dot <- pointsGrob(x = coords$x,
                       y = coords$middle,
                       pch = coords$shape,
                       size = unit(coords$dotsize, "char"))
  
  gTree(children = gList(ci_line, ci_dot))

}

GeomBootCI <- ggproto("GeomBootCI", Geom,
                      required_aes = c("x", "ymin", "ymax", "middle"),
                      default_aes = aes(linesize = 0.8,
                                        dotsize = 0.5,
                                        shape = 19, 
                                        lwd = 2,
                                        lineend = "square"),
                      draw_key = draw_key_point,
                      draw_panel = draw_panel_boot_ci)

geom_bootci <- function(mapping = NULL, data = NULL, stat = "identity", 
                           position = "identity", show.legend = NA, 
                           na.rm = FALSE, inherit.aes = TRUE, ...) {
        layer(data = data, 
              mapping = mapping,
              stat = stat,
              geom = GeomBootCI,
              position = position,
              show.legend = show.legend,
              inherit.aes = inherit.aes,
              params = list(na.rm = na.rm, ...))
}
```

## delta_plot helper functions
```{r}
create_deltaplot_components <- function(proportional, 
                                        is_paired, 
                                        float_contrast,
                                        is_colour,
                                        delta2) {
  main_violin_type <- "multicolour"
  is_summary_lines <- TRUE
  is_bootci <- TRUE
  is_deltadelta <- FALSE
  
  if(isTRUE(is_paired) || isTRUE(is_colour)) {
    main_violin_type <- "singlecolour"
  }
  if(isTRUE(delta2)) {
    is_deltadelta <- TRUE
  }
  if(isFALSE(float_contrast)) {
    is_summary_lines <- FALSE
  }
  
  plot_component <- list(
    main_violin_type = main_violin_type,
    is_summary_lines = is_summary_lines,
    is_bootci = is_bootci,
    is_deltadelta = is_deltadelta
  )
  return(plot_component)
}

create_violinplot_components <- function(boots, 
                                         idx, 
                                         float_contrast, 
                                         delta_y_max,
                                         delta_y_min) {
  df_for_violin <- data.frame(
    x = NA,
    y = NA,
    tag = NA
  )
  
  x_axis_breaks <- c()
  curr_boot_idx = 1
  curr_x_idx = 0
  
  for (group in idx) {
    curr_x_idx <- curr_x_idx + 1
    temp_df_violin <- data.frame(x = NA,
                                 y = NA,
                                 tag = toString(curr_x_idx))
    
    df_for_violin <- rbind(df_for_violin, temp_df_violin)
    
    for (i in 2:length(group)) {
      curr_x_idx <- curr_x_idx + 1
      x_axis_breaks <- append(x_axis_breaks, curr_x_idx)
      
      ci_coords <- density(boots[[curr_boot_idx]])
      
      x_coords_ci <- ci_coords$x
      y_coords_ci <- ci_coords$y
      
      # Standardise y
      y_coords_ci <- (y_coords_ci - min(y_coords_ci))/(max(y_coords_ci) - min(y_coords_ci))
      y_coords_ci <- y_coords_ci/6
      
      if (isFALSE(float_contrast)) {
        y_coords_ci <- y_coords_ci/1.5
      }
      
      y_coords_ci <- y_coords_ci + curr_x_idx
      
      min_x_coords <- min(x_coords_ci)
      max_x_coords <- max(x_coords_ci)
      
      # Keeping track of ylim limits
      if (min_x_coords < delta_y_min) {
        delta_y_min <- min_x_coords
      }
      if (max_x_coords > delta_y_max) {
        delta_y_max <- max_x_coords
      }
      
      temp_df_violin <- data.frame(x = x_coords_ci,
                                   y = y_coords_ci,
                                   tag = rep(toString(curr_x_idx),512))
      
      df_for_violin <- rbind(df_for_violin, temp_df_violin)
      
      curr_boot_idx <- curr_boot_idx + 1
    }
  }
  df_for_violin <- df_for_violin %>%
    arrange(tag, x , y)
  
  plot_component <- list(
    df_for_violin = df_for_violin,
    delta_y_min = delta_y_min,
    delta_y_max = delta_y_max,
    x_axis_breaks = x_axis_breaks
  )
  
  return(plot_component)
}
```

# delta_plot function 
```{r}
plot_delta <- function(dabest_effectsize_obj, float_contrast, plot_kwargs) {
  idx = dabest_effectsize_obj$idx
  bootstraps = dabest_effectsize_obj$bootstraps
  
  delta_x_labels = unlist(dabest_effectsize_obj$delta_x_labels)
  delta_y_labels = dabest_effectsize_obj$delta_y_labels
  
  minimeta = dabest_effectsize_obj$minimeta
  delta2 = dabest_effectsize_obj$delta2
  is_colour <- dabest_effectsize_obj$is_colour
  is_paired <- dabest_effectsize_obj$is_paired
  
  raw_y_range_vector <- dabest_effectsize_obj$ylim
  control_summary <- dabest_effectsize_obj$control_summary
  test_summary <- dabest_effectsize_obj$test_summary
  
  # Initialising x & y limits
  delta_x_max = length(unlist(idx))
  delta_y_min = .Machine$double.xmax
  delta_y_max = .Machine$double.xmin
  
  # Obtain boot
  boot_result <- dabest_effectsize_obj$boot_result
  boots <- boot_result$bootstraps
  
  # Extracting geom_bootci params
  ci_low = boot_result$bca_ci_low
  ci_high = boot_result$bca_ci_high
  difference = boot_result$difference
  
  # Check if multiplot
  if(length(unlist(idx)) >= 3) {
    float_contrast <- FALSE
  }
  
  #### Deltaplot Building ####
  delta_plot_components <- create_deltaplot_components(proportional, 
                                                       is_paired, 
                                                       float_contrast,
                                                       is_colour,
                                                       delta2)
  main_violin_type <- delta_plot_components$main_violin_type
  is_summary_lines <- delta_plot_components$is_summary_lines
  is_bootci <- delta_plot_components$is_bootci
  is_deltadelta <- delta_plot_components$is_deltadelta
  
  #### initialise delta_plot & Add main_violin_type component ####
  # Extend idx if minimeta or deltadelta
  if (isTRUE(minimeta) || isTRUE(delta2)) {
    idx <- c(idx, list(c("minimeta", "deltadelta")))
  }
  
  violin_plot_components <- create_violinplot_components(boots, 
                                                         idx, 
                                                         float_contrast, 
                                                         delta_y_max,
                                                         delta_y_min)
  
  df_for_violin <- violin_plot_components$df_for_violin
  delta_y_min <- violin_plot_components$delta_y_min
  delta_y_max <- violin_plot_components$delta_y_max
  delta_y_mean <- (delta_y_max - delta_y_min)/2
  x_axis_breaks <- violin_plot_components$x_axis_breaks
  
  delta_plot <- switch(
    main_violin_type,
    
    "multicolour" = 
      ggplot() +
      geom_halfviolin(na.rm = TRUE, 
                      data = df_for_violin,
                      aes(x = y, y = x, fill = tag)),
    
    "singlecolour" = 
      ggplot() +
      geom_halfviolin(na.rm = TRUE, 
                      data = df_for_violin,
                      aes(x = y, y = x, group = tag))
  )
  
  #### Add scaling Component ####
  if (isTRUE(float_contrast)) {
    # Calculate new ylims to align summary lines
    min_raw_y <- raw_y_range_vector[1]
    max_raw_y <- raw_y_range_vector[2]
    raw_y_range <- max_raw_y - min_raw_y
    min_y_coords <- difference/(1 - (test_summary - min_raw_y)/(control_summary - min_raw_y))
    delta_y_range <- raw_y_range * -min_y_coords/(control_summary - min_raw_y)
    
    delta_plot <- delta_plot +
      theme_classic() +
      coord_cartesian(ylim = c(min_y_coords, min_y_coords + delta_y_range),
                      xlim = c(1.8,delta_x_max+0.25),
                      expand = FALSE) +
      scale_x_continuous(breaks = c(2),
                         labels = delta_x_labels) +
      scale_y_continuous(position = "right") 
    
  } else {
    # Extend xaxis for minimeta/deltadelta.
    if (isTRUE(minimeta) || isTRUE(delta2)) {
      delta_x_max <- delta_x_max + 2
      
      if (isTRUE(minimeta)) {
      } else {
        delta_x_labels <- append(delta_x_labels, "delta-delta")
      }
    }
    
    delta_plot <- delta_plot +
      theme_classic() +
      coord_cartesian(ylim = c(delta_y_min - delta_y_mean/2, 
                               delta_y_max + delta_y_mean/2),
                      xlim = c(0.6, delta_x_max+0.5),
                      expand = FALSE) +
      scale_x_continuous(breaks = x_axis_breaks,
                         labels = delta_x_labels)
  }
  
  #### Add bootci Component ####
  if (isTRUE(is_bootci)) {
    delta_plot <- delta_plot +
      geom_bootci(
        aes(x = x_axis_breaks,
            ymin = ci_low,
            ymax = ci_high,
            middle = difference))
  }
  
  #### Add summary lines Component ####
  if (isTRUE(is_summary_lines)) {
    delta_plot <- delta_plot +
      geom_segment(colour = "black", 
                   linewidth = 0.3, 
                   aes(x = 1.8, 
                       xend = delta_x_max+0.25, 
                       y = difference, 
                       yend = difference)) +
      geom_segment(colour = "black", 
                   linewidth = 0.3, 
                   aes(x = 1.8, 
                       xend = delta_x_max+0.25, 
                       y = 0, 
                       yend = 0))
  }
  
  #### Remove xaxis and redraw xaxis component ####
  if (isTRUE(float_contrast)) {
    delta_plot <- delta_plot +
      float_contrast_theme +
      geom_hline(linewidth = 0.8,
                 yintercept = min_y_coords)
  } else {
    # Obtain xaxis line and ticks elements for xaxis redraw
    dfs_for_xaxis_redraw <- create_dfs_for_xaxis_redraw(idx)
    df_for_line <- dfs_for_xaxis_redraw$df_for_line
    df_for_ticks <- dfs_for_xaxis_redraw$df_for_ticks
    
    delta_plot <- delta_plot + 
      non_float_contrast_theme +
      
      # Redraw xaxis line
      geom_segment(data = df_for_line,
                   linewidth = 0.5,
                   lineend = "square", 
                   color = "black",
                   aes(x = x, 
                       xend = xend, 
                       y = delta_y_min - delta_y_mean/3.5, 
                       yend = delta_y_min - delta_y_mean/3.5)) +
      
      # Redraw xaxis ticks
      geom_segment(data = df_for_ticks,
                   linewidth = 0.5,
                   lineend = "square", 
                   color = "black",
                   aes(x = x, 
                       xend = x, 
                       y = delta_y_min - delta_y_mean/3.5, 
                       yend = delta_y_min - delta_y_mean/2))
  }
  
  #### Add y = 0 line Component ####
  if (isFALSE(float_contrast)) {
    delta_plot <- delta_plot +
      geom_segment(colour = "black", 
                   linewidth = 0.3, 
                   aes(x = 0.6, 
                       xend = delta_x_max+0.5, 
                       y = 0, 
                       yend = 0))
  }
  
  #### Add y_labels Component ####
  delta_plot <- delta_plot +
    labs(y = delta_y_labels)
  
  #### Add deltadelta yaxis Component
  if (isTRUE(is_deltadelta)) {
    delta_delta_plot <- ggplot() +
      theme_classic() +
      non_float_contrast_theme +
      
      # Setting scaling and limits
      coord_cartesian(ylim = c(delta_y_min - delta_y_mean/2, 
                               delta_y_max + delta_y_mean/2),
                      xlim = c(0, 1),
                      expand = FALSE) +
      scale_x_continuous(breaks = c(0.5),
                         labels = "") +
      labs(y = "delta-delta") +
      scale_y_continuous(position = "right") +
      
      # Drawing y = 0 line
      geom_hline(linewidth = 0.3,
                 yintercept = 0)
    
    delta_plot <- cowplot::plot_grid(
      plotlist = list(delta_plot + theme(legend.position="none",
                                         plot.margin = ggplot2::unit(c(5.5, 0, 5.5, 0), "pt")), 
                      delta_delta_plot + theme(legend.position="none",
                                               plot.margin = ggplot2::unit(c(5.5, 0, 5.5, 0), "pt"))),
      nrow = 1, 
      rel_widths = c(1, 0.1),
      axis = "lr",
      align = "h"
      )
  }
  
  return(delta_plot)
}
```

# palette applier
```{r}
apply_palette <- function(ggplot_object, palette_name) {
  ggplot_object <- switch(
    palette_name,
    
    "npg" =
      ggplot_object + scale_color_npg() + scale_fill_npg(),
    
    "aaas" = 
      ggplot_object + scale_color_aaas() + scale_fill_aaas(),
    
    "nejm" = 
      ggplot_object + scale_color_nejm() + scale_fill_nejm(),
    
    "lancet" = 
      ggplot_object + scale_color_lancet() + scale_fill_lancet(),
    
    "jama" = 
      ggplot_object + scale_color_jama() + scale_fill_jama(),
    
    "jco" = 
      ggplot_object + scale_color_jco() + scale_fill_jco(),
    
    "ucscgb" = 
      ggplot_object + scale_color_ucscgb() + scale_fill_ucscgb(),
    
    "d3" = 
      ggplot_object + scale_color_d3() + scale_fill_d3(),
    
    "locuszoom" = 
      ggplot_object + scale_color_locuszoom() + scale_fill_locuszoom(),
    
    "igv" = 
      ggplot_object + scale_color_igv() + scale_fill_igv(),
    
    "cosmic" = 
      ggplot_object + scale_color_cosmic() + scale_fill_cosmic(),
    
    "uchicago" = 
      ggplot_object + scale_color_uchicago() + scale_fill_uchicago(),
    
    "brewer" = 
      ggplot_object + scale_color_brewer() + scale_fill_brewer(),
    
    "ordinal" = 
      ggplot_object + scale_color_ordinal() + scale_fill_ordinal(),
    
    "viridis_d" = 
      ggplot_object + scale_color_viridis_d() + scale_fill_viridis_d()
  )
  
  return(ggplot_object)
}
```

# dabest_plot functin
```{r}
dabest_plot <- function(dabest_obj.mean_diff, float_contrast = TRUE, ...) {
  plot_kwargs <- list(...)
  plot_kwargs <- assign_plot_kwargs(plot_kwargs)
  
  custom_palette <- plot_kwargs$custom_palette
  
  is_colour <- dabest_obj.mean_diff$is_colour
  idx <- dabest_obj.mean_diff$idx
  raw_legend <- NULL
  
  if(length(unlist(idx)) >= 3) {
    float_contrast <- FALSE
  }
  
  if (isFALSE(float_contrast)) {
    
    raw_plot <- apply_palette(plot_raw(dabest_obj.mean_diff, float_contrast=FALSE, plot_kwargs), custom_palette)
    delta_plot <- apply_palette(plot_delta(dabest_obj.mean_diff, float_contrast=FALSE, plot_kwargs), custom_palette)
    
    if(isTRUE(is_colour)) {
      raw_legend <- get_legend(raw_plot + 
                                 guides(alpha = "none") +
                                 theme(legend.box.margin = margin(0, 0, 0, 0)))
    }
    
    final_plot <- cowplot::plot_grid(
      plotlist   = list(raw_plot + theme(legend.position="none"), 
                        raw_legend, 
                        delta_plot + theme(legend.position="none"),
                        NULL),
      nrow       = 2,
      ncol       = 2,
      rel_widths = c(0.9, 0.1),
      axis       = "lr",
      align      = "b")
    
    return(final_plot)
    
  } else {
    
    raw_plot <-  apply_palette(plot_raw(dabest_obj.mean_diff, float_contrast=TRUE, plot_kwargs), custom_palette)
    delta_plot <- apply_palette(plot_delta(dabest_obj.mean_diff, float_contrast=TRUE, plot_kwargs), custom_palette)
    
    if(isTRUE(is_colour)) {
      raw_legend <- get_legend(raw_plot + 
                                 guides(color = guide_legend(nrow = 1),
                                        alpha = "none") + 
                                 theme(legend.position = "bottom"))
    }
    
    final_plot <- cowplot::plot_grid(
      plotlist   = list(raw_plot + theme(legend.position="none"), 
                        delta_plot + theme(legend.position="none")),
      nrow       = 1,
      ncol       = 2,
      rel_widths = c(0.8, 0.2),
      axis       = "lr",
      align      = "h")
    
    final_plot <- cowplot::plot_grid(final_plot, raw_legend, ncol = 1, rel_heights = c(1, 0.1))
    
    return(final_plot)
  }
  
  final_plot
}
```

# Testing dataset
```{r}
set.seed(12345)

N = 40
c1 <- rnorm(N, mean = 100, sd = 25)
c2 <- rnorm(N, mean = 100, sd = 50)
g1 <- rnorm(N, mean = 120, sd = 25)
g2 <- rnorm(N, mean = 110, sd = 50)
g3 <- rnorm(N, mean = 100, sd = 12)
g4 <- rnorm(N, mean = 100, sd = 50)
gender <- c(rep('Male', N/2), rep('Female', N/2))
dummy <- rep("Dummy", N)
id <- 1: N

wide.data <- tibble::tibble(
  Control1 = c1, Control2 = c2,
  Group1 = g1, Group2 = g2, Group3 = g3, Group4 = g4,
  Dummy = dummy,
  Gender = gender, ID = id)

my.data <- wide.data %>%
  tidyr::gather(key = Group, value = Measurement, -ID, -Gender, -Dummy)
```


# Testing unpaired plots
```{r}
dabest_obj <- load(data = my.data, x = Group, y = Measurement, idx = c("Control1", "Group1"))
dabest_obj.mean_diff <- mean_diff(dabest_obj)
# dabest_obj.hedges_g <- hedges_g(dabest_obj)

# alternative way of plotting is
# dabest_obj.mean_diff.plot <- load(data = my.data, x = Group, y = Measurement, idx = c("Control1", "Group1")) %>%
#   mean_diff() %>%
#   dabest_plot()
# 
# dabest_obj.mean_diff.plot
```

```{r}
dabest_plot(dabest_obj.mean_diff, TRUE)
dabest_plot(dabest_obj.mean_diff, FALSE, custom_palette = "nejm")
```

## unpaired colour
```{r}
dabest_obj.colour_mean_diff <- load(data = my.data, x = Group, y = Measurement, idx = c("Control1", "Group1"), colour = Gender) %>%
  mean_diff()

dabest_plot(dabest_obj.colour_mean_diff, TRUE, custom_palette = "jama")
dabest_plot(dabest_obj.colour_mean_diff, FALSE, custom_palette = "jco")
```

# multigroup
## multigroup unpaired
```{r}
dabest_obj_multigroup <- load(data = my.data, x = Group, y = Measurement, idx = list(c("Control1", "Group1"), c("Control2", "Group2", "Group3")))
dabest_obj_multigroup.mean_diff <- mean_diff(dabest_obj_multigroup)
```

```{r}
dabest_plot(dabest_obj_multigroup.mean_diff, TRUE)
dabest_plot(dabest_obj_multigroup.mean_diff, FALSE, custom_palette = "jama")
```

## unpaired multiplot colour
```{r}
dabest_obj.colour_mean_diff <- load(data = my.data, x = Group, y = Measurement, idx = c("Control1", "Group1", "Group2", "Group3"), colour = Gender) %>%
  mean_diff()

dabest_plot(dabest_obj.colour_mean_diff, FALSE, custom_palette = "jco")
```


# Testing paired plots 
```{r}
dabest_obj_multigroup_sequential <- load(data = my.data, x = Group, y = Measurement, idx = list(c("Control2", "Group2", "Group3"), c("Control1", "Group1")), paired = "sequential", id_col = ID)
dabest_obj_multigroup_sequential.mean_diff <- mean_diff(dabest_obj_multigroup_sequential)

dabest_obj_multigroup_baseline <- load(data = my.data, x = Group, y = Measurement, idx = list(c("Control2", "Group2", "Group3"), c("Control1", "Group1")), paired = "baseline", id_col = ID)
dabest_obj_multigroup_baseline.mean_diff <- mean_diff(dabest_obj_multigroup_baseline)
```

```{r}
dabest_plot(dabest_obj_multigroup_sequential.mean_diff, FALSE)
dabest_plot(dabest_obj_multigroup_baseline.mean_diff, FALSE)
```

```{r}
dabest_obj.colour_baseline_mean_diff <- load(data = my.data, x = Group, y = Measurement, idx = list(c("Control2", "Group2", "Group3"), c("Control1", "Group1")), paired = "baseline", id_col = ID, colour = Gender) %>%
  mean_diff()

dabest_obj.colour_sequential_mean_diff <- load(data = my.data, x = Group, y = Measurement, idx = list(c("Control2", "Group2", "Group3"), c("Control1", "Group1")), paired = "sequential", id_col = ID, colour = Gender) %>%
  mean_diff()
```

```{r}
dabest_plot(dabest_obj.colour_baseline_mean_diff, TRUE, custom_palette = "nejm")
dabest_plot(dabest_obj.colour_sequential_mean_diff, TRUE, custom_palette = "jco")
```

# Testing proportional dataset
```{r}
set.seed(54321)

N = 40

my.data.control_proportional <- data.frame(
  Group = sample(c("Control1"), 40, TRUE)
)
my.data.control_proportional$Success <- numeric(nrow(my.data.control_proportional))
my.data.control_proportional$Success[sample(nrow(my.data.control_proportional), 8)] <- 1

my.data.test_proportion1 <- data.frame(
  Group = sample(c("Test1"), 40, TRUE)
)
my.data.test_proportion1$Success <- numeric(nrow(my.data.test_proportion1))
my.data.test_proportion1$Success[sample(nrow(my.data.test_proportion1), 22)] <- 1

my.data.test_proportion2 <- data.frame(
  Group = sample(c("Test2"), 40, TRUE)
)
my.data.test_proportion2$Success <- numeric(nrow(my.data.test_proportion2))
my.data.test_proportion2$Success[sample(nrow(my.data.test_proportion2), 15)] <- 1

my.data.proportional <- rbind(my.data.control_proportional, my.data.test_proportion1, my.data.test_proportion2)
id <- data.frame(ID = rep(c(1:40), 3))
my.data.proportional <- cbind(my.data.proportional, id)
```

```{r}
dabest_obj_proportional.mean_diff <- load(data = my.data.proportional, 
                                  x = Group, 
                                  y = Success, 
                                  idx = c("Control1", "Test1"),
                                  proportional = TRUE) %>%
  mean_diff()
```

```{r}
dabest_plot(dabest_obj_proportional.mean_diff, TRUE, custom_palette = "igv") 
dabest_plot(dabest_obj_proportional.mean_diff, FALSE, custom_palette = "uchicago")
```

```{r}
dabest_obj_proportional_multigroup.cohens_h <- load(data = my.data.proportional, 
                                  x = Group, 
                                  y = Success, 
                                  idx = c("Control1", "Test1", "Test2"),
                                  proportional = TRUE) %>%
  cohens_h()
```

```{r}

dabest_plot(dabest_obj_proportional_multigroup.cohens_h, TRUE, custom_palette = "brewer")
dabest_plot(dabest_obj_proportional_multigroup.cohens_h, FALSE)
```

```{r}
dabest_obj_sankey.mean_diff <- load(data = my.data.proportional, 
                                  x = Group, 
                                  y = Success, 
                                  idx = c("Control1", "Test1"),
                                  proportional = TRUE,
                                  paired = "baseline",
                                  id_col = ID) %>%
  mean_diff()
```

```{r}
dabest_plot(dabest_obj_sankey.mean_diff, FALSE)
```
# Testing minimeta dataset
```{r}
set.seed(12345)

N = 20
c1 <- rnorm(N, mean = 3, sd = 0.4)
c2 <- rnorm(N, mean = 3.5, sd = 0.75)
c3 <- rnorm(N, mean = 3.25, sd = 0.4)
g1 <- rnorm(N, mean = 3.5, sd = 0.5)
g2 <- rnorm(N, mean = 2.5, sd = 0.6)
g3 <- rnorm(N, mean = 3, sd = 0.75)
gender <- c(rep('Male', N/2), rep('Female', N/2))
dummy <- rep("Dummy", N)
id <- 1: N

wide.data <- tibble::tibble(
  Control1 = c1, Control2 = c2, Control3 = c3,
  Group1 = g1, Group2 = g2, Group3 = g3,
  Dummy = dummy,
  Gender = gender, ID = id)

my.data <- wide.data %>%
  tidyr::gather(key = Group, value = Measurement, -ID, -Gender, -Dummy)
```

# Testing minimeta & deltadelta w/0 actual minimeta and deltadelta functionalities
```{r}
dabest_obj_multigroup_minimeta <- load(data = my.data, x = Group, y = Measurement, minimeta = TRUE, idx = list(c("Control1", "Group1"), c("Control2", "Group2"), c("Control3", "Group3")))
dabest_obj_multigroup_minimeta.mean_diff <- mean_diff(dabest_obj_multigroup_minimeta)

dabest_obj_multigroup_deltadelta <- load(data = my.data, x = Group, y = Measurement, delta2 = TRUE, idx = list(c("Control1", "Group1"), c("Control2", "Group2", "Group3")))
dabest_obj_multigroup_deltadelta.mean_diff <- mean_diff(dabest_obj_multigroup_deltadelta)
dabest_obj_multigroup_deltadelta.mean_diff$boot_result <- 
  rbind(dabest_obj_multigroup_deltadelta.mean_diff$boot_result, dabest_obj_multigroup_deltadelta.mean_diff$boot_result[3,])
```

```{r}
dabest_plot(dabest_obj_multigroup_minimeta.mean_diff, TRUE)
dabest_plot(dabest_obj_multigroup_deltadelta.mean_diff, TRUE)
```