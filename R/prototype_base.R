
#' Prepare Data for Analysis with dabestr
#'
#' @param .data A data.frame or tibble.
#'
#' @param x,y Columns in \code{.data}.
#'
#' @param idx A vector containing factors or strings in the \code{x} columns.
#'   These must be quoted (ie. surrounded by quotation marks). The first element
#'   will be the control group, so all differences will be computed for every
#'   other group and this first group.
#'
#' @param paired boolean, default FALSE. If TRUE, the two groups are treated as
#'   paired samples. The \code{control_group} group is treated as
#'   pre-intervention and the \code{test_group} group is considered
#'   post-intervention.
#'
#' @param id.column, default NULL. A column name indicating the identity of the
#'   datapoint if the data is paired. This must be supplied if paired is TRUE.
#'
#'
#' @return A list with 7 elements: \code{data}, \code{x}, \code{y}, \code{idx},
#'  and \code{id.column}.
#'
#'   \code{data}, \code{x}, \code{y}, \code{id.column}, and \code{idx} are the
#'   same keywords supplied to \code{dabest} as noted above. \cr \cr \code{x}
#'   and \code{y} are quoted variables for tidy evaluation by \code{plot}.
#'

#' @importFrom magrittr %>%
#'
#' @export
dabest_proto <- function(
  .data, x, y, idx, paired = FALSE, id.column = NULL) {

  #### Create quosures and quonames. ####
  data_enquo     <- rlang::enquo(.data)
  data_quoname   <- rlang::quo_name(data_enquo)

  x_enquo        <-  rlang::enquo(x)
  x_quoname      <-  rlang::quo_name(x_enquo)

  y_enquo        <-  rlang::enquo(y)
  y_quoname      <-  rlang::quo_name(y_enquo)

  id.col_enquo   <-  rlang::enquo(id.column)


  if (identical(paired, TRUE) & rlang::quo_is_null(id.col_enquo)) {
    stop("`paired` is TRUE but no `id.col` was supplied.")
  }



  #### Get only the columns we need. ####
  data_for_diff <-
    tibble::as_tibble(.data) %>%
    dplyr::select(!!x_enquo, !!y_enquo, !!id.col_enquo)



  #### Handled if paired. ####
  if (isTRUE(paired)) {
    id.col_quoname <-  rlang::quo_name(id.col_enquo)
    # sort the data by id.col so we can be sure all the observations match up.
    data_for_diff  <-
      data_for_diff %>% dplyr::arrange(!!x_enquo, !!id.col_enquo)
  }



  #### Decide if multiplot or not. ####
  if (class(idx) == "character") {
    # Not multiplot. Add it to an empty list.
    group_list  <-  list(idx)
    all.groups  <-  idx

  } else if (class(idx) == "list") {
    # This is a multiplot. Give it a new name.
    group_list  <-  idx
    all.groups  <-  unique(unlist(group_list)) # Flatten `group_list`.
  }


  #### Assemble only the data used to create the plot. ####
  data.out <- .data

  # New in v0.2.1 patch.
  # Basically, the `ellipsis` package has been updated,
  # and now forcats::as_factor() should only take the object to coerce.
  data.out[[x_quoname]] <- forcats::as_factor(data.out[[x_quoname]])

  data.out <- dplyr::filter(data.out, !!x_enquo %in% all.groups)



  #### Collate output. ####
  out = list(
    data        = data.out,
    x           = x_enquo,
    y           = y_enquo,
    idx         = group_list,
    id.column   = id.col_enquo,
    is.paired   = paired,
    .data.name  = data_quoname,
    .all.groups = all.groups
  )



  #### Append the custom class `dabest`. ####
  class(out) <- c("dabest_proto", "list")


  #### Return the output. ####
  return(out)
}




#' Print a `dabest_proto` object
#'
#' @param dabest.object A \code{proto_dabest} object, generated by the function of the same name.
#'
#' @param ... Signature for S3 generic function.
#'
#'
#' @return A summary of the experimental designs.
#'
#' @examples
#' # Performing unpaired (two independent groups) analysis.
#' unpaired_mean_diff <- dabest(iris, Species, Petal.Width,
#'                              idx = c("setosa", "versicolor"),
#'                              paired = FALSE)
#'
#' # Display the results in a user-friendly format.
#' print(unpaired_mean_diff)
#'
#' @export
print.dabest_proto <- function(dabest.object, ...) {

  #### Check object class ####
  if (class(dabest.object)[1] != "dabest_proto") {
    stop(paste(
      "The object you are plotting is not a `dabest_proto` class object. ",
      "Please check again! ")
    )
  }

  #### Print greeting header. ####
  print_greeting_header()

  #### Print head of data? ####
  cat(stringr::str_interp("Dataset    :  ${dabest.object$.data.name}\n"))
  cat("The first five rows are:\n")
  print(head(dabest.object$data, n = 5L))
  cat("\n")

  #### Print xvar and yvar. ####
  xvar = rlang::quo_name(dabest.object$x)
  yvar = rlang::quo_name(dabest.object$y)

  cat(stringr::str_interp("X Variable :  ${xvar}\n"))
  cat(stringr::str_interp("Y Variable :  ${yvar}\n\n"))

  #### Loop thru the groups and print out the comparisons to be done. ####
  if (dabest.object$is.paired) {
    es = "Paired effect size(s)"
  } else {
    es = "Effect sizes(s)"
  }
  cat(es, "will be computed for:\n")

  print_each_comparison(dabest.object)

  cat("\n")
}



print_greeting_header <- function() {
  now = Sys.time()

  now.hour <- as.integer(strftime(now, "%H"))

  if (0 < now.hour & now.hour < 12) {
    greeting = "Good morning!\n"
  } else if (12 < now.hour & now.hour < 18) {
    greeting = "Good afternoon!\n"
  } else {
    greeting = "Good evening!\n"
  }


  dabest_ver <- utils::packageVersion("dabestr")
  header     <- stringr::str_interp(
    "dabestr (Data Analysis with Bootstrap Estimation in R) v${dabest_ver}\n")

  cat(header)

  cat(rep('=', nchar(header) - 1), sep='')
  cat("\n\n")

  cat(greeting)
  cat("The current time is", strftime(now, "%R %p on %A %B %d, %Y."))
  cat("\n\n")
}



print_each_comparison <- function(dabest.object, ...) {

  i <- 1

  for (group in dabest.object$idx) {
    # Get test groups (everything else in group), loop through them and compute
    # the difference between group[1] and each group.
    # Test groups are the 2nd element of group onwards.

    control_group = group[1]
    test_groups <- group[2: length(group)]

    for (current_test_group in test_groups) {
      cat(stringr::str_interp("  ${i}. ${current_test_group} minus ${control_group}\n"))
      i <- i + 1
    }
  }

}
