
#' Estimation Plot
#'
#' An estimation plot has two key features.
#' \enumerate{
#'   \item{It presents all datapoints as a
#'   \href{https://github.com/eclarke/ggbeeswarm#introduction}{swarmplot} or
#'   \href{https://cran.r-project.org/web/packages/sinaplot/vignettes/SinaPlot.html}{sinaplot},
#'   which orders each point to display the underlying distribution.}
#'   \item{It presents the effect size as a bootstrap 95 percent confidence
#'         interval on a separate but aligned axes.}
#' }
#' Estimation plots emerge from estimation statistics, an inutitive framework
#' that avoids the pitfalls of significance testing. It uses familiar
#' statistical concepts: means, mean differences, and error bars.
#' More importantly, it focuses on the effect size of one's
#' experiment/intervention, as opposed to a false dichotomy engendered
#' by \emph{P} values.
#' This function takes the output of the \code{\link{dabest}} function
#' and produces an estimation plot.
#'
#' @param dabest.object A \code{dabest} object, generated by the function
#' of the same name.
#' @param slopegraph boolean, default TRUE. If the \code{dabest} object contains
#' paired comparisons, \code{slopegraph = TRUE} will plot the rawdata as a
#' \href{http://charliepark.org/slopegraphs/}{Tufte slopegraph}.
#' @param float.contrast default TRUE.  If \code{idx} in the \code{dabest}
#' object contains only 2 groups, \code{float.contrast = TRUE} will plot the
#' effect size and the bootstrap confidence interval in a horizontally-aligned
#' axes (also known as a \href{https://bit.ly/2NhqUAb}{Gardner-Altman plot.})
#' @param color.column default NULL
#' @param palette default "Set1". Accepts any one of the ggplot2 palettes.
#' See the "Palettes" section ins \link{scale_color_brewer}.
#' @param theme default theme_classic()
#' @param tick.fontsize default 12
#' @param axes.title.fontsize default 15
#' @param swarm.label default NULL
#' @param es.label default NULL
#' @param esmarker.size default 3
#' @param rawplot.type default "beeswarm. Accepts any value found in
#' c("beeswarm", "sinaplot")
#' @param swarmplot.params default NULL. Supply list of
#' \code{keyword = value} pairs to \code{ggbeeswarm::geom_beeswarm()}
#' (if float.contrast = TRUE) or \code{ggbeeswarm::geom_quasirandom()}
#' (if float.contrast = FALSE).
#' @param sinaplot.params default NULL. Supply list of
#' \code{keyword = value} pairs to \code{ggforce::geom_sina()}.
#' @param slopegraph.params default NULL. Supply list of
#' \code{keyword = value} pairs to \code{ggplot2::geom_line()}. This
#' controls the appearance of the lines plotted for a paired slopegraph.
#'
#' @return A \code{ggplot} object.
#'
#' @seealso
#' The \code{\link{dabest}} function.
#'
#' @section References:
#' Moving beyond P values: Everyday data analysis with estimation plots. (2018)
#' Joses Ho, Tayfun Tumkaya, Sameer Aryal, Hyungwon Choi, Adam Claridge-Chang
#'
#' \url{https://doi.org/10.1101/377978}
#'
#'
#' @examples
#' dabest.plot(iris, x = Species, y = Petal.Width,
#'             idx = c("setosa", "versicolor"))
#'
#' @export
plot.dabest <- function(dabest.object,
                    color.column = NULL, palette = "Set1",
                    float.contrast = TRUE,
                    slopegraph = TRUE,
                    theme = theme_classic(),
                    tick.fontsize = 11,
                    axes.title.fontsize = 14,
                    swarm.label = NULL,
                    es.label = NULL,
                    esmarker.size = 3,
                    rawplot.type = c("swarmplot", "sinaplot"),
                    swarmplot.params = NULL,
                    sinaplot.params = NULL,
                    slopegraph.params = NULL) {

  #### Extract variables ####
  # Create handles for easy access to the items in `dabest.object`.
  raw.data           <-  dabest.object$data
  boot.result        <-  dabest.object$result
  idx                <-  dabest.object$idx
  id.col             <-  dabest.object$id.column
  summary            <-  dabest.object$summary

  # The variables below should are quosures!
  x_enquo            <-  dabest.object$x
  y_enquo            <-  dabest.object$y
  x_quoname          <-  quo_name(x_enquo)
  y_quoname          <-  quo_name(y_enquo)
  # `func` is not a quosure but a string.
  func               <-  boot.result$func[1]
  is.paired          <-  boot.result$paired[1]

  # Compute the Ns.
  Ns                 <-  raw.data %>% group_by(!!x_enquo) %>% count()
  Ns$swarmticklabs   <-  do.call(paste, c(Ns[c(x_quoname, "n")],
                                         sep = "\nN = "))
  Ns$deltaticklabs   <-  c(" ", paste(boot.result$test_group,
                                      str_interp("minus ${idx[1]}"),
                                      sep = "\n"))



  #### Parse keywords. ####
  # float.contrast (and slopegraph)
  if (isFALSE(is.paired)) slopegraph <- FALSE

  if (length(idx) > 2) {
      float.contrast <- FALSE
      slopegraph     <- FALSE
  }


  # color.column
  color.col_enquo      <-  enquo(color.column)
  if (quo_is_null(color.col_enquo)) {
    color.aes          <-  aes(col = !!x_enquo)
  } else {
    color.col_quoname  <-  quo_name(color.col_enquo)
    color.aes          <-  aes(col = !!color.col_enquo)
  }


  # rawplot.type
  # If rawplot is not specified, defaults to 'swarmplot'.
  if (length(rawplot.type) > 1) {
    rawplot.type <- rawplot.type[1]
  }


  # *plot.params.
  if (isFALSE(slopegraph)) {

    if (rawplot.type == 'swarmplot') {
      if (is.null(swarmplot.params)) {
        if (isTRUE(float.contrast)) {
          swarmplot.params <- list(size = 1, alpha = 0.95, cex = 1)
        } else {
          swarmplot.params <- list(width = 0.25)
        }
      } else if (class(swarmplot.params) != "list") {
        stop("`swarmplot.params` is not a list.")
      }
      swarmplot.params[['mapping']] = color.aes

    } else if (rawplot.type == 'sinaplot') {
      if (is.null(sinaplot.params)) {
        sinaplot.params <- list(mapping = color.aes)
      } else if (class(sinaplot.params) != "list") {
        stop("`sinaplot.params` is not a list.")
      } else sinaplot.params[['mapping']] = color.aes

    } else stop(paste(rawplot.type, "is not a recognized plot type. ",
                      "Accepted plot types: 'swarmplot' and 'sinaplot'."))
  } else {
    # Munge rawdata for slopegraph plotting.
    rawplot.type <- "slopegraph"
    # for.slope.plot <- raw.data %>% spread(key = !!x_enquo, value = !!y_enquo)
  }



  #### Create themes. ####
  horizontal.line.width = 0.1

  non.floating.theme <-
    theme +
    theme(axis.text            =  element_text(size = tick.fontsize),
          axis.title           =  element_text(size = axes.title.fontsize),
          axis.ticks.length    =  unit(7, "points"),
          axis.ticks.x.bottom  =  element_blank(),
          axis.title.x.bottom  =  element_blank())

  floating.theme     <-
    non.floating.theme +
    theme(#axis.line.x.bottom   =  element_blank(),
          axis.title.x.bottom  =  element_blank(),
          axis.ticks.x.bottom  =  element_blank())

  legend.theme       <-
    theme(legend.title         =  element_text(size = axes.title.fontsize),
          legend.text          =  element_text(size = tick.fontsize))

  non.floating.theme <-  non.floating.theme + legend.theme
  floating.theme     <-  floating.theme + legend.theme


  #### Plot raw data. ####
  rawdata.plot <-
    ggplot(data = raw.data,
           aes(!!x_enquo, !!y_enquo)) +
    scale_color_brewer(palette = palette) +
    ylab(str_interp("${y_quoname}\n")) +
    scale_x_discrete(labels = Ns$swarmticklabs)

    if (rawplot.type == 'swarmplot') {
      if (isTRUE(float.contrast)) {
        rawdata.plot <-
          rawdata.plot +
          do.call(ggbeeswarm::geom_beeswarm, swarmplot.params) +
          floating.theme

      } else {
        rawdata.plot <-
          rawdata.plot +
          do.call(ggbeeswarm::geom_quasirandom, swarmplot.params) +
          non.floating.theme
      }


    } else if (rawplot.type == 'sinaplot') {
      rawdata.plot   <-
        rawdata.plot +
        do.call(ggforce::geom_sina, sinaplot.params)

      if (isTRUE(float.contrast)) {
        rawdata.plot <- rawdata.plot + floating.theme
      } else {
         rawdata.plot <- rawdata.plot + non.floating.theme
      }


    } else if (rawplot.type == 'slopegraph') {
      if (quo_is_null(color.col_enquo)) {
        rawdata.plot <- rawdata.plot +
          floating.theme +
          geom_line(aes(group = !!id.col))
      } else {
        rawdata.plot <- rawdata.plot +
          floating.theme +
          geom_line(aes(group = !!id.col, color = !!color.col_enquo),
                    size = horizontal.line.width)
      }
    }


  # Plot the summary lines for each group if `float.contrast` is TRUE.
  if (isTRUE(float.contrast)) {
    func_control <- summary[[func]][1]
    func_test <- summary[[func]][2]
    control.summary.line.aes <- aes(x = 1, xend = 3,
                                    y = func_control,
                                    yend = func_control)
    test.summary.line.aes <- aes(x = 2, xend = 3,
                                 y = func_test,
                                 yend = func_test)
    rawdata.plot <- rawdata.plot +
      # Plot the summary lines for each group.
      geom_segment(color =  "black", size = horizontal.line.width,
                   mapping = control.summary.line.aes) +
      geom_segment(color =  "black", size = horizontal.line.width,
                   mapping = test.summary.line.aes)
  }




  #### Munge bootstraps. ####
  # Munge bootstraps into tibble for easy plotting with ggplot.
  boots.for.plot <- as_tibble(data.frame(boot.result$bootstraps))
  if (isTRUE(float.contrast)) {
    colnames(boots.for.plot) <- idx[2] # NOT 1.
  } else {
    # Add the control group as a set of NaNs.
    boots.for.plot <-
      boots.for.plot %>%
      add_column( placeholder = rep(NaN, nrow(boots.for.plot)) )

    colnames(boots.for.plot) <- c(boot.result$test_group, idx[1])
  }

  boots.for.plot <-
    tidyr::gather(boots.for.plot, !!x_enquo, !!y_enquo)

  # Order the bootstraps so they plot in the correct order.
  boots.for.plot[[x_quoname]] <-
    factor(boots.for.plot[[x_quoname]], idx, ordered = TRUE)

  boots.for.plot <-
    arrange(boots.for.plot, !!x_enquo)



  #### Plot bootstraps. ####
  es0.line.aes <- aes(x = 0, xend = length(idx) + 1,
                      y = 0, yend = 0)
  delta.plot <-
    ggplot(boots.for.plot, na.rm = TRUE) +
    geom_flat_violin(na.rm = TRUE, adjust = 5, size = 0,
                     aes(!!x_enquo, !!y_enquo)) +
    # This is the line representing effect size  = 0.
    geom_segment(color =  "black", size = horizontal.line.width,
                 mapping = es0.line.aes)


  #### Plot effect sizes and CIs. ####
  if (isTRUE(boot.result$paired[1])) {
    delta.ylab <- str_interp("Paired ${boot.result$func[1]} difference\n")
  } else {
    delta.ylab <- str_interp("Unpaired ${boot.result$func[1]} difference\n")
  }

  delta.plot <-
    delta.plot +
    ylab(delta.ylab) +
    geom_point(data = boot.result,
               color = "black", size = esmarker.size,
               aes(test_group, difference)) +
    geom_errorbar(data = boot.result,
                  color = "black", width = 0, size = 0.75,
                  aes(x = test_group,
                      ymin = bca_ci_low,
                      ymax = bca_ci_high))


  #### Touch up delta plot. ####
  if (isTRUE(float.contrast)) {
    # Draw the lone violinplot as a floating contrast.
    # Get rawdata.plot ylims.
    swarm.ylims <-
      ggplot_build(rawdata.plot)$layout$panel_scales_y[[1]]$range$range
    # Shift ylims appropriately.
    if (func_control > 0) {
      swarm.ylims <- swarm.ylims - func_control
    } else {
      swarm.ylims <- swarm.ylims + func_control
    }
    effsize  = func_test - func_control
    delta.plot <- delta.plot +
      coord_cartesian(ylim = swarm.ylims) +
      scale_y_continuous(position = "right") +
      # This is the delta-side effect size line, that aligns with
      # the central measure of the test group.
      geom_segment(color =  "black", size = horizontal.line.width,
                   aes(x = 0, xend = 3,
                       y = effsize, yend = effsize)) +
      scale_x_discrete(labels = c("\n")) +
      floating.theme

    # spacer <-
    #   ggplot() +
    #   coord_cartesian(ylim = swarm.ylims) +
    #   geom_segment(color = "red", size = horizontal.line.width,
    #                aes(x = 0, xend = 3,
    #                    y = 0, yend = 0)) +
    #   geom_segment(color = "red", size = horizontal.line.width,
    #                aes(x = 0, xend = 3,
    #                    y = effsize, yend = effsize)) +
    #   floating.theme +
    #   theme(axis.line   = element_blank(),
    #         axis.title  = element_blank(),
    #         axis.text.x = element_blank(),
    #         axis.text.y = element_blank(),
    #         axis.ticks  = element_blank(),
    #         plot.margin = unit(c(0, 0, 0, 0), "pt")
    #         )

  } else {
    # Plot nonfloating deltas.
    delta.plot <- delta.plot +
      scale_x_discrete(labels = Ns$deltaticklabs) +
      non.floating.theme
  }

  #### Handle color legend. ####
  if (!quo_is_null(color.col_enquo)) {
    legend <- cowplot::get_legend(rawdata.plot)
  }
  # Remove the legend from the rawplot.
  rawdata.plot <- rawdata.plot + guides(color = "none")



  #### Determine layout. ####
  if (isTRUE(float.contrast)) {
    # Side-by-side floating plot layout.
    # plot.margin declares the top, right, bottom, left margins in order.
    rawdata.plot <- rawdata.plot +
      theme(plot.margin = unit(c(5.5, 0, 5.5, 5.5), "pt"))

    delta.plot   <- delta.plot +
      theme(plot.margin = unit(c(5.5, 5.5, 5.5, 0), "pt"),
            axis.line.x.bottom = element_blank())


    aligned_spine = 'b'
    nrows <- 1

    if (quo_is_null(color.col_enquo)) {
      plist <- list(rawdata.plot, delta.plot)
      ncols <- 2
      widths <- c(0.7, 0.3)
    } else {
      plist <- list(rawdata.plot, delta.plot, legend)
      ncols <- 3
      widths <- c(0.7, 0.3, 0.2)
    }

  } else {
    # Above-below non-floating plot layout.
    aligned_spine = 'lr'
    nrows <- 2

    if (quo_is_null(color.col_enquo)) {
      plist <- list(rawdata.plot, delta.plot)
      ncols <- 1
      widths <- c(1)
    } else {
      plist <- list(rawdata.plot, legend, delta.plot)
      ncols <- 2
      widths <- c(0.85, 0.15)
    }
  }

  result <- cowplot::plot_grid(
            plotlist = plist,
            nrow = nrows, ncol = ncols,
            rel_widths = widths,
            axis = aligned_spine)

  return(result)
}




#' @export
geom_flat_violin <- function(mapping = NULL, data = NULL, stat = "ydensity",
                             position = "dodge", trim = TRUE, scale = "area",
                             show.legend = NA, inherit.aes = TRUE, ...) {

  layer(data = data, mapping = mapping, stat = stat,
        geom = GeomFlatViolin, position = position, show.legend = show.legend,
        inherit.aes = inherit.aes,
        params = list(trim = trim,scale = scale, ...)
  )
}



"%||%" <- function(a, b) {
  if (!is.null(a)) a else b
}



GeomFlatViolin <-
  ggplot2::ggproto(
    "GeomFlatViolin",

    ggplot2::Geom,

    setup_data = function(data, params) {
      data$width <- data$width %||%
        params$width %||%
        (resolution(data$x, FALSE) * 0.9)
      # ymin, ymax, xmin, and xmax define the bounding rectangle for each group.
      data %>%
        dplyr::group_by(group) %>%
        dplyr::mutate(ymin = min(y),
                      ymax = max(y),
                      xmin = x,
                      xmax = x + width / 2)
    },

    draw_group = function(data, panel_scales, coord) {
      # Find the points for the line to go all the way around
      data <- transform(data, xminv = x,
                        xmaxv = x + violinwidth * (xmax - x))

      # Make sure it's sorted properly to draw the outline
      newdata <- rbind(plyr::arrange(transform(data, x = xminv), y),
                       plyr::arrange(transform(data, x = xmaxv), -y))

      # Close the polygon: set first and last point the same.
      # Needed for coord_polar and such.
      newdata <- rbind(newdata, newdata[1,])

      ggplot2:::ggname("geom_flat_violin",
                       GeomPolygon$draw_panel(newdata,
                                              panel_scales, coord))
    },

    draw_key = ggplot2::draw_key_polygon,

    default_aes = ggplot2::aes(weight = 1, colour = "grey20",
                               fill = "grey", size = 0.5,
                               alpha = NA, linetype = "solid"),

    required_aes = c("x", "y")
