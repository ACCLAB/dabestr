
#' Estimation Plot
#'
#' An estimation plot has two key features.
#' \enumerate{
#'   \item{It presents all datapoints as a
#'   \href{https://github.com/eclarke/ggbeeswarm#introduction}{swarmplot} or
#'   \href{https://cran.r-project.org/web/packages/sinaplot/vignettes/SinaPlot.html}{sinaplot},
#'   which orders each point to display the underlying distribution.}
#'   \item{It presents the effect size as a bootstrap 95 percent confidence
#'         interval on a separate but aligned axes.}
#' }
#' Estimation plots emerge from estimation statistics, an inutitive framework
#' that avoids the pitfalls of significance testing. It uses familiar
#' statistical concepts: means, mean differences, and error bars.
#' More importantly, it focuses on the effect size of one's
#' experiment/intervention, as opposed to a false dichotomy engendered
#' by \emph{P} values.
#' This function takes the output of the \code{\link{dabest}} function
#' and produces an estimation plot.
#'
#' @param dabest.object A \code{dabest} object, generated by the function
#' of the same name.
#' @param slopegraph boolean, default TRUE. If the \code{dabest} object contains
#' paired comparisons, \code{slopegraph = TRUE} will plot the rawdata as a
#' \href{http://charliepark.org/slopegraphs/}{Tufte slopegraph}.
#' @param float.contrast default TRUE.  If \code{idx} in the \code{dabest}
#' object contains only 2 groups, \code{float.contrast = TRUE} will plot the
#' effect size and the bootstrap confidence interval in a horizontally-aligned
#' axes (also known as a \href{https://bit.ly/2NhqUAb}{Gardner-Altman plot.})
#' @param color.column default NULL
#' @param palette default "Set1". Accepts any one of the ggplot2 palettes.
#' See the "Palettes" section ins \link{scale_color_brewer}.
#' @param theme default theme_classic()
#' @param tick.fontsize default 12
#' @param axes.title.fontsize default 15
#' @param swarm.label default NULL
#' @param es.label default NULL
#' @param rawmarker.size default 2
#' @param esmarker.size default 4
#' @param rawplot.type default "beeswarm. Accepts any value found in
#' c("beeswarm", "sinaplot")
#' @param swarmplot.params default NULL. Supply list of
#' \code{keyword = value} pairs to \code{ggbeeswarm::geom_beeswarm()}
#' (if float.contrast = TRUE) or \code{ggbeeswarm::geom_quasirandom()}
#' (if float.contrast = FALSE).
#' @param sinaplot.params default NULL. Supply list of
#' \code{keyword = value} pairs to \code{ggforce::geom_sina()}.
#' @param slopegraph.params default NULL. Supply list of
#' \code{keyword = value} pairs to \code{ggplot2::geom_line()}. This
#' controls the appearance of the lines plotted for a paired slopegraph.
#'
#' @return A \code{ggplot} object.
#'
#' @seealso
#' The \code{\link{dabest}} function.
#'
#' @section References:
#' Moving beyond P values: Everyday data analysis with estimation plots. (2018)
#' Joses Ho, Tayfun Tumkaya, Sameer Aryal, Hyungwon Choi, Adam Claridge-Chang
#'
#' \url{https://doi.org/10.1101/377978}
#'
#'
#' @examples
#' paired_mean_diff <- dabest(
#'                       iris, Species, Petal.Width,
#'                       idx = c("setosa", "versicolor", "virginica"),
#'                       paired = FALSE)
#' plot(paired_mean_diff, color.col = Species)
#'
#' @export
plot.dabest <- function(dabest.object,
                        color.column        = NULL,
                        palette             = "Set1",
                        float.contrast      = TRUE,
                        slopegraph          = TRUE,
                        theme               = theme_classic(),
                        tick.fontsize       = 11,
                        axes.title.fontsize = 14,
                        swarm.label         = NULL,
                        es.label            = NULL,
                        rawmarker.size      = 2,
                        esmarker.size       = 4,
                        rawplot.type        = c("swarmplot", "sinaplot"),
                        swarmplot.params    = NULL,
                        sinaplot.params     = NULL,
                        slopegraph.params   = NULL) {

  #### Extract variables ####
  # Create handles for easy access to the items in `dabest.object`.
  raw.data           <-  dabest.object$data
  boot.result        <-  dabest.object$result
  idx                <-  dabest.object$idx
  id.col             <-  dabest.object$id.column
  summary            <-  dabest.object$summary

  plot.groups.sizes  <-  unlist(lapply(idx, length))
  all.groups         <-  unlist(idx)

  # The variables below should are quosures!
  x_enquo            <-  dabest.object$x
  y_enquo            <-  dabest.object$y
  x_quoname          <-  quo_name(x_enquo)
  y_quoname          <-  quo_name(y_enquo)
  # `func` is not a quosure but a string.
  func               <-  boot.result$func[1]
  is.paired          <-  boot.result$paired[1]


  #### Parse keywords. ####
  # float.contrast and slopegraph
  if (isFALSE(is.paired)) slopegraph <- FALSE

  if (max(plot.groups.sizes) > 2) {
      float.contrast <- FALSE
      slopegraph     <- FALSE
  }

  if (length(all.groups) > 2) {
    float.contrast <- FALSE
  }



  #### Decide if multiplot or not. ####
  if (length(all.groups)     == 2 &&
      plot.groups.sizes[[1]] == 2) {
    # Not multiplot. Add it to an empty list.
    for.plot <- raw.data

  } else {
    # Reorder the plot data according to idx.
    for.plot <- list()
    for (subplot_groups in idx) {
      subplot  <- filter(raw.data, !!x_enquo %in% subplot_groups)
      for.plot[[length(for.plot) + 1]] <- subplot
    }

    for.plot <- bind_rows(for.plot)

    for.plot[[x_quoname]] <-
      for.plot[[x_quoname]] %>%
      factor(all.groups, ordered = TRUE)
  }


  #### Compute the Ns. ####
  Ns                 <-  for.plot %>% group_by(!!x_enquo) %>% count()

  Ns$swarmticklabs   <-  do.call(paste, c(Ns[c(x_quoname, "n")],
                                         sep = "\nN = "))


  # color.column
  color.col_enquo      <-  enquo(color.column)
  if (quo_is_null(color.col_enquo)) {
    color.aes          <-  aes(col = !!x_enquo)
    swarm.dodge        <-  0
  } else {
    color.col_quoname  <-  quo_name(color.col_enquo)
    color.aes          <-  aes(col = !!color.col_enquo)
    swarm.dodge        <-  0.1
  }


  # rawplot.type
  # If rawplot is not specified, defaults to 'swarmplot'.
  if (length(rawplot.type) > 1) {
    rawplot.type <- rawplot.type[1]
  }


  # *plot.params.
  if (isFALSE(slopegraph)) {

    if (rawplot.type == 'swarmplot') {
      if (is.null(swarmplot.params)) {
        if (isTRUE(float.contrast)) {
          swarmplot.params <- list(size = rawmarker.size,
                                   dodge.width = swarm.dodge,
                                   alpha = 0.95,
                                   cex = 1)
        } else {
          swarmplot.params <- list(width = 0.25)
        }
      } else if (class(swarmplot.params) != "list") {
        stop("`swarmplot.params` is not a list.")
      }
      swarmplot.params[['mapping']] = color.aes

    } else if (rawplot.type == 'sinaplot') {
      if (is.null(sinaplot.params)) {
        sinaplot.params <- list(size = rawmarker.size,
                                mapping = color.aes)
      } else if (class(sinaplot.params) != "list") {
        stop("`sinaplot.params` is not a list.")
      } else sinaplot.params[['mapping']] = color.aes

    } else stop(paste(rawplot.type, "is not a recognized plot type. ",
                      "Accepted plot types: 'swarmplot' and 'sinaplot'."))
  } else {
    rawplot.type <- "slopegraph"
  }



  #### Create themes. ####
  horizontal.line.width = 0.4

  non.floating.theme <-
    theme +
    theme(axis.text            =  element_text(size = tick.fontsize),
          axis.title           =  element_text(size = axes.title.fontsize),
          axis.ticks.length    =  unit(7, "points"),
          axis.ticks.x.bottom  =  element_blank(),
          axis.title.x.bottom  =  element_blank())

  floating.theme <-
    non.floating.theme +
    theme(axis.title.x.bottom  =  element_blank(),
          axis.ticks.x.bottom  =  element_blank())

  legend.theme <-
    theme(legend.title         =  element_text(size = axes.title.fontsize),
          legend.text          =  element_text(size = tick.fontsize))


  non.floating.theme <-  non.floating.theme + legend.theme
  floating.theme     <-  floating.theme + legend.theme


  remove.axes <-
    theme(axis.line.x          = element_blank(),
          axis.title.x         = element_blank(),
          axis.ticks.x.bottom  = element_blank())



  #### Plot raw data. ####
  # slopegraph.
  if (rawplot.type == "slopegraph") {

    rawdata.plot <- ggplot() +
      ylab(str_interp("${y_quoname}\n")) +
      scale_x_discrete(labels = Ns$swarmticklabs, limits = all.groups)

    slope.line.width  <- 0.5

    for (subplot_groups in idx) {
      subplot  <- filter(raw.data, !!x_enquo %in% subplot_groups)

      subplot[[x_quoname]] <-
        subplot[[x_quoname]] %>%
        factor(subplot_groups, ordered = TRUE)

       if (quo_is_null(color.col_enquo)) {
          rawdata.plot <- rawdata.plot +
            geom_line(data = subplot,
                      size = slope.line.width,
                      alpha = 0.8,
                      aes(!!x_enquo, !!y_enquo,
                          group = !!id.col))
        } else {
          rawdata.plot <- rawdata.plot +
            geom_line(data = subplot,
                      size = slope.line.width,
                      alpha = 0.75,
                      aes(!!x_enquo, !!y_enquo,
                          group = !!id.col,
                          colour = !!color.col_enquo))
        }
    }

    # Add x-labels.
    rawdata.plot <- rawdata.plot +
      ylab(str_interp("${y_quoname}\n"))

  } else {


    # swarmplot.
    rawdata.plot <-
      ggplot(data = for.plot,
             aes(!!x_enquo, !!y_enquo)) +
      scale_color_brewer(palette = palette) +
      ylab(str_interp("${y_quoname}\n")) +
      scale_x_discrete(labels = Ns$swarmticklabs)

      if (rawplot.type == 'swarmplot') {
        if (isTRUE(float.contrast)) {
          rawdata.plot <-
            rawdata.plot +
            do.call(ggbeeswarm::geom_beeswarm, swarmplot.params) +
            floating.theme

        } else {
          rawdata.plot <-
            rawdata.plot +
            do.call(ggbeeswarm::geom_quasirandom, swarmplot.params) +
            non.floating.theme
        }


      } else if (rawplot.type == 'sinaplot') {
        rawdata.plot   <-
          rawdata.plot +
          do.call(ggforce::geom_sina, sinaplot.params)

        if (isTRUE(float.contrast)) {
          rawdata.plot <- rawdata.plot + floating.theme
        } else {
          rawdata.plot <- rawdata.plot + non.floating.theme
          }
        }
  }

  # Plot the summary lines for each group if `float.contrast` is TRUE.
  if (isTRUE(float.contrast)) {
    func_control <- summary[[func]][1]
    func_test    <- summary[[func]][2]

    # # I seem to be having difficulty getting the line thicknesses equal
    # # between the slopegraph and the delta axes? Need this hack...
    # if (isTRUE(slopegraph)) mult <- 1.5 else mult <- 1

    rawdata.plot <- rawdata.plot +
      # Plot the summary lines for the control group...
      geom_segment(color = "black",
                   size = horizontal.line.width,
                   aes(x = 1, xend = 3,
                       y = func_control,
                       yend = func_control)) +

      # ... and the test group.
      geom_segment(color = "black",
                   size = horizontal.line.width,
                   aes(x = 2, xend = 3,
                       y = func_test,
                       yend = func_test))

    # Apply appropriate theme to swarm plot.
    rawdata.plot <- rawdata.plot + floating.theme
  } else {
    rawdata.plot <- rawdata.plot + non.floating.theme
  }



  #### Munge bootstraps. ####
  # Munge bootstraps into tibble for easy plotting with ggplot.
  boots.for.plot <- as_tibble(data.frame(boot.result$bootstraps))
  colnames(boots.for.plot) <- boot.result$test_group

  if (isFALSE(float.contrast)) {
    # Add the control group as a set of NaNs.
    for (control.column in unique(boot.result$control_group)) {
      oldcols <- colnames(boots.for.plot)
      boots.for.plot <-
        boots.for.plot %>%
        add_column(placeholder = rep(NaN, nrow(boots.for.plot)))

      colnames(boots.for.plot) <- c(oldcols, control.column)
    }
  }

  boots.for.plot <-
    tidyr::gather(boots.for.plot, !!x_enquo, !!y_enquo)

  # Order the bootstraps so they plot in the correct order.
  boots.for.plot[[x_quoname]] <-
    factor(boots.for.plot[[x_quoname]], all.groups, ordered = TRUE)

  boots.for.plot <-
    arrange(boots.for.plot, !!x_enquo)



  #### Plot bootstraps. ####
  if (isTRUE(float.contrast)) {
    es0.trimming       <- 1
    flat_violin_width  <- 1
    flat_violin_adjust <- 5
  } else {
    es0.trimming       <- 0.5
    flat_violin_width  <- 0.75
    flat_violin_adjust <- 3
  }

  delta.plot <-
    ggplot(boots.for.plot, na.rm = TRUE) +
    geom_flat_violin(na.rm = TRUE,
                     width = flat_violin_width,
                     adjust = flat_violin_adjust,
                     size = 0,
                     aes(!!x_enquo, !!y_enquo)) +
    # This is the line representing the null effect size.
    geom_segment(color =  "black", size = horizontal.line.width,
                 x = 0, xend = length(all.groups) + es0.trimming,
                 y = 0, yend = 0)



  #### Plot effect sizes and CIs. ####
  if (isTRUE(boot.result$paired[1])) {
    delta.ylab <- str_interp("Paired ${boot.result$func[1]} difference\n")
  } else {
    delta.ylab <- str_interp("Unpaired ${boot.result$func[1]} difference\n")
  }

  delta.plot <-
    delta.plot +
    ylab(delta.ylab) +
    geom_point(data = boot.result,
               color = "black", size = esmarker.size,
               aes(test_group, difference)) +
    geom_errorbar(data = boot.result,
                  color = "black", width = 0, size = 0.75,
                  aes(x = test_group,
                      ymin = bca_ci_low,
                      ymax = bca_ci_high))



  #### Trim rawdata axes. ####
  rawdata.plot <-  rawdata.plot + remove.axes

  # Get the ylims.
  rawdata.plot.build       <- ggplot_build(rawdata.plot)
  rawdata.plot.build.panel <- rawdata.plot.build$layout$panel_params[[1]]
  rawdata.plot.ylim        <- rawdata.plot.build.panel$y.range
  segment.ypos             <- rawdata.plot.ylim[1]

  rawdata.plot.xlim        <- rawdata.plot.build.panel$x.range
  rawdata.plot.lower.xlim  <- rawdata.plot.xlim[1]

  if (isTRUE(float.contrast)  && isTRUE(slopegraph)) {
    rawdata.plot.smallest.ytick <-
      rawdata.plot.build.panel$y.major_source[1]

    rawdata.plot.ytick.interval <-
      abs(abs(rawdata.plot.build.panel$y.major_source[2]) -
            abs(rawdata.plot.smallest.ytick)
          )

    segment.ypos <- rawdata.plot.smallest.ytick - rawdata.plot.ytick.interval
  }


  # Set padding to add.
  start.idx          <- 1
  padding            <- 0.25

  if (isTRUE(float.contrast)) {
    segment.thickness <- 0.5
  } else {
    segment.thickness <- 0.75
  }


  # Re-draw the trimmed axes.
  for (size in plot.groups.sizes) {
    end.idx      <- start.idx + size - 1

    if (isTRUE(float.contrast)) {
      xstart   <- rawdata.plot.lower.xlim
    } else {
      xstart <- start.idx - padding
    }

    if (isFALSE(slopegraph)) {

      if (isTRUE(float.contrast)) {
        xend     <- end.idx   + padding * 1.5
      } else {
        xend     <- end.idx   + padding
      }

      rawdata.plot <- rawdata.plot +
        geom_segment(x    = xstart,
                     xend = xend,
                     y    = segment.ypos,
                     yend = segment.ypos,
                     size = segment.thickness)

    } else {
      rawdata.plot <- rawdata.plot +
        geom_segment(size = segment.thickness,
                     aes_(x    = xstart,
                          xend = end.idx + padding,
                          y    = segment.ypos,
                          yend = segment.ypos)
                     )
    }
    start.idx  <- start.idx + size
  }



  #### Touch up delta plot. ####
  if (isTRUE(float.contrast)) {
    # Draw the lone violinplot as a floating contrast.
    # Get rawdata.plot ylims.
    swarm.ylims <-
      ggplot_build(rawdata.plot)$layout$panel_scales_y[[1]]$range$range

    # Shift ylims appropriately.
    if (func_control > 0) {
      swarm.ylims <- swarm.ylims - func_control
    } else {
      swarm.ylims <- swarm.ylims + func_control
    }

    delta.plot <- delta.plot +
      coord_cartesian(ylim = swarm.ylims) +
      scale_y_continuous(position = "right") +
      # This is the delta-side effect size line,
      # that aligns with the central measure of the test group.
      geom_segment(color = "black",
                   size = horizontal.line.width,
                   x = 0, xend = 3,
                   y = boot.result$difference[1],
                   yend = boot.result$difference[1]) +
      # Need to simulate a dummy x-label for plot alignment.
      scale_x_discrete(
        labels = c(str_interp("${all.groups[2]}\nminus ${all.groups[1]}"))
        ) +
      floating.theme

  } else {
    # Plot nonfloating deltas.
    # Properly concatenate the delta.plot labels.
    delta.tick.labs  <- vector("list", length(idx))
    i <- 1
    for (subplot_groups in idx) {
      control_group <- subplot_groups[1]
      test_groups   <- subplot_groups[2: length(subplot_groups)]

      labels <- c(" ",
                  paste(test_groups, str_interp("minus\n${control_group}"),
                        sep = "\n"))

      delta.tick.labs[[i]] = labels
      i <- i + 1
    }
    # Equalize the xlims across both plots.
    both.xlim    <- c(1, length(all.groups) + 0.3)

    if (isFALSE(float.contrast)) {
      rawdata.plot <- rawdata.plot + coord_cartesian(xlim = both.xlim)
    }

    delta.plot   <- delta.plot +
      coord_cartesian(xlim = both.xlim) +
      scale_x_discrete(labels = delta.tick.labs) +
      non.floating.theme
  }



  #### Trim deltaplot axes. ####
  delta.plot   <-  delta.plot   + remove.axes

  # Get the ylims.
  delta.plot.build         <- ggplot_build(delta.plot)
  delta.plot.build.panel   <- delta.plot.build$layout$panel_params[[1]]
  delta.plot.ylim          <- delta.plot.build.panel$y.range
  segment.ypos             <- delta.plot.ylim[1]
  delta.plot.upper.ylim    <- delta.plot.ylim[2]

  delta.plot.xlim          <- delta.plot.build.panel$x.range
  delta.plot.lower.xlim    <- delta.plot.xlim[1]

  # Set padding to add.
  start.idx          <- 1

  # Re-draw the trimmed axes.
  for (size in plot.groups.sizes) {
    end.idx      <- start.idx + size - 1

    if (isTRUE(float.contrast)) {
      xstart     <- delta.plot.lower.xlim
      xend       <- end.idx   + padding * 3

      delta.plot <- delta.plot +
        geom_segment(x    = 1 - (padding * 3),
                     xend = delta.plot.upper.ylim,
                     y    = segment.ypos,
                     yend = segment.ypos,
                     size = segment.thickness)
    } else {
      xstart     <- start.idx - padding
      xend       <- end.idx   + padding
      delta.plot <- delta.plot +
        geom_segment(x    = xstart,
                     xend = xend,
                     y    = segment.ypos,
                     yend = segment.ypos,
                     size = segment.thickness)

    }
    start.idx  <- start.idx + size
  }



  #### Handle color legend. ####
  if (!quo_is_null(color.col_enquo)) {
    legend <- cowplot::get_legend(rawdata.plot)
  }
  # Remove the legend from the rawplot.
  rawdata.plot <- rawdata.plot + guides(color = "none")



  #### Equalize tick label lengths. ####
  if (isFALSE(float.contrast)) {
    rawplot.yticks           <- get_tick_labels(rawdata.plot, axes="y")
    max_rawplot_ticklength   <- max_nchar_ticks(rawplot.yticks)

    deltaplot.yticks         <- get_tick_labels(delta.plot, axes="y")
    max_deltaplot_ticklength <- max_nchar_ticks(deltaplot.yticks)


    if (max_rawplot_ticklength < max_deltaplot_ticklength) {
      space.diff <- max_deltaplot_ticklength - max_rawplot_ticklength

      suffix.spacing   <- rep(" ", space.diff)

      rawplot.yticks   <- paste(str_interp(suffix.spacing), rawplot.yticks)

      rawdata.plot     <- rawdata.plot +
                          scale_y_continuous(labels = rawplot.yticks)


    } else if (max_rawplot_ticklength > max_deltaplot_ticklength) {
      space.diff = max_rawplot_ticklength - max_deltaplot_ticklength

      suffix.spacing   <- rep(" ", space.diff)

      deltaplot.yticks <- paste(str_interp(suffix.spacing), deltaplot.yticks)

      delta.plot       <- delta.plot +
                          scale_y_continuous(labels = deltaplot.yticks)
    }
  }




  #### Determine layout. ####
  if (isTRUE(float.contrast)) {
    # Side-by-side floating plot layout.
    # plot.margin declares the top, right, bottom, left margins in order.
    rawdata.plot <- rawdata.plot +
      theme(plot.margin = unit(c(5.5, 0, 5.5, 5.5), "pt"))

    delta.plot   <- delta.plot +
      theme(plot.margin = unit(c(5.5, 5.5, 5.5, 0), "pt"),
            axis.line.x.bottom = element_blank())

    aligned_spine = 'b'
    nrows <- 1

    if (quo_is_null(color.col_enquo)) {
      plist <- list(rawdata.plot, delta.plot)
      ncols <- 2
      widths <- c(0.7, 0.3)
    } else {
      plist <- list(rawdata.plot, delta.plot, legend)
      ncols <- 3
      widths <- c(0.7, 0.3, 0.2)
    }

  } else {
    # Above-below non-floating plot layout.
    aligned_spine = 'lr'
    nrows <- 2

    if (quo_is_null(color.col_enquo)) {
      plist <- list(rawdata.plot, delta.plot)
      ncols <- 1
      widths <- c(1)
    } else {
      plist <- list(rawdata.plot, legend, delta.plot)
      ncols <- 2
      widths <- c(0.85, 0.15)
    }
  }

  result <- cowplot::plot_grid(
            plotlist = plist,
            nrow = nrows, ncol = ncols,
            rel_widths = widths,
            axis = aligned_spine)

  return(result)
}






